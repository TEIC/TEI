<?xml version="1.0" encoding="utf-8"?>
<!--
Copyright TEI Consortium. 
Licensed under the GNU General Public License. 
See the file COPYING for details.
$Date$
$Id$
-->
<div xmlns="http://www.tei-c.org/ns/1.0" type="div1" xml:id="ST" n="3">

<head>The TEI Infrastructure</head>

<p>This chapter describes the infrastructure for the encoding scheme
defined by these Guidelines.  It introduces the conceptual framework
within which the following chapters are to be understood, and
introduces the means by which that conceptual framework is
implemented.  It assumes some familiarity with XML and XML schemas
(see chapter <ptr target="#SG"/>) but is intended to be accessible to
any user of these Guidelines. Other chapters supply further technical
details, in particular chapter <ptr target="#TD"/> which describes the
XML schema used to express the Guidelines themselves, and chapter <ptr
target="#USE"/> which combines a discussion of modification and
conformance issues with a description of the intended behaviour of an
ODD processor; these chapters should be read by anyone intending to
implement a new TEI-based system. </p>

<p>The TEI encoding scheme consists of a number of
<term>modules</term>, each of which declares particular XML elements
and their attributes. Part of an element's declaration includes its
assignment to one or more element <term>classes</term>. Another part
defines its possible content and atttributes with reference to these
classes, rather than explicitly.  This indirection gives the TEI
system much of its strength and its flexibility. Modules, and their
contents, may be combined more or less freely to form a
<term>schema</term> appropriate to a particular set of
requirements. It is also easy to add new elements which reference
existing classes or elements to a schema, as it is to remove existing
elements from a schema.
	</p>

<p>In principle, a TEI schema may be constructed using any combination
of modules. However, certain TEI modules are of particular importance,
and should always be included in all but exceptional circumstances:
the module <ident type="module">tei</ident> described in the present
chapter is of this kind because it defines classes, macros, and
datatypes which are used by all other modules. The <ident
type="module">core</ident> module, defined in chapter <ptr
target="#CO"/> contains declarations for elements and attributes which
are likely to be needed in almost any kind of document, and is
therefore recommended for global use. The <ident
type="module">header</ident> module defined in chapter <ptr
target="#HD"/> provides declarations for the metadata elements and
attributes constituting the TEI Header, a component which is required
for TEI conformance, while the <ident
type="module">textstructure</ident> module defined in chapter <ptr
target="#DS"/> declares basic structural elements needed for the
encoding of almost any text-like object. Most schemas will therefore
need to include these four modules, but are free to mix and match them
with others.</p>

<p>The specification for a TEI schema is itself a TEI document, using
elements from the module described in chapter <ptr target="#TD"/>: we
refer to such a document informally as an <term>ODD</term> document,
from the design goal originally formulated for the system: <q>One
Document Does it all</q>. Stylesheets for maintaining and processing
ODD documents are maintained by the TEI, and these Guidelines are also
maintained as such a document. As further discussed in <ptr
target="#IM"/>, an ODD document can be processed to generate a schema
expressed using any of the three schema languages currently in wide
use: the XML DTD language, the ISO RELAX NG language, or the W3C
Schema language, as well as to generate documentation such as the
<title>Guidelines</title> and their associated website. </p>

<p>The bulk of this chapter describes the TEI infrastructure module
itself. Although it may be skipped at a first reading, an
understanding of the topics addressed here is essential for anyone
planning to take full advantage of the TEI customization techniques
described in chapter <ptr target="#MD"/>. </p>

<p>The chapter begins by briefly characterizing each of the modules
available in the TEI scheme. Section <ptr target="#STIN" type="div2"/>
describes in general terms the method of constructing  a TEI schema
in a specific schema language such as XML DTD language, RELAX NG, or
W3C Schema. </p>

<!--
<p>The <term>global attributes</term>, characteristics postulated of
every element  in the encoding scheme, are discussed in section 
<ptr target="#STGA" type="div2"/>.</p>
-->

<p>The next and largest part of the chapter introduces the three
fundamental components of the TEI infrastructure:
<list>
<item>declarations for all 
<term>element classes</term> used to define groups of elements and
their characteristics (section <ptr target="#STEC"/>)</item>
<item>definition of the <term>datatypes</term> used to constrain the
range of legal values for TEI attributes (section <ptr target="#DTYPES"/>)</item>
<item>definition of other <term>macros</term> used to express some
commonly used content models (section <ptr target="#STmacros"/>)</item>
</list>
</p>
<!-- STPE is now a part of IM -->

<div type="div2" xml:id="STMA"><head>TEI Modules</head>

<p>These Guidelines define several hundred elements and attributes for
marking up documents of any kind. Each definition combines a prose
description, provided within a chapter of the Guidelines and in the
reference lists, with a formal declaration, expressed for reference by
means of the ISO schema language RELAX NG. For convenience, each
element is assigned to a single module, typically for use in some
specific application area, or to support a particular kind of usage.
 </p>

<p>Corresponding with each module, the TEI provides a <term>schema
fragment</term> in each of three supported schema languages. A TEI
schema is made by combining these fragments, each of which contains
sets of declarations, as further described in section <ptr
target="#STIN"/> below. </p>


<p>The following table lists the modules defined by the
current release of the Guidelines:

<!-- table can be re-autogenerated from modules.xsl LB 20-xii-05 -->

<table xml:id="tab-mods">
<row role="label">
<cell>Module name</cell>
<cell>Formal public identifier</cell>
<cell>Where defined</cell>
</row>
<row><cell>analysis</cell><cell>Analysis and Interpretation</cell><cell><ptr target="#AI"/></cell></row>
<row><cell>certainty</cell><cell>Certainty and Uncertainty</cell><cell><ptr target="#CE"/></cell></row>
<row><cell>core</cell><cell>Common Core</cell><cell><ptr target="#CO"/></cell></row>
<row><cell>corpus</cell><cell>Metadata for Language Corpora</cell><cell><ptr target="#CC"/></cell></row>
<!--<row><cell>declarefs</cell><cell>Feature System Declaration</cell><cell><ptr target="#FD"/></cell></row>-->
<row><cell>dictionaries</cell><cell>Print Dictionaries</cell><cell><ptr target="#DI"/></cell></row>
<row><cell>drama</cell><cell>Performance Texts</cell><cell><ptr target="#DR"/></cell></row>
<row><cell>figures</cell><cell>Tables, Formulae, Figures</cell><cell><ptr target="#FT"/></cell></row>
<row><cell>gaiji</cell><cell>Character and Glyph Documentation</cell><cell><ptr target="#WD"/></cell></row>
<row><cell>header</cell><cell>Common Metadata</cell><cell><ptr target="#HD"/></cell></row>
<row><cell>iso-fs</cell><cell>Feature Structures</cell><cell><ptr target="#FS"/></cell></row>
<row><cell>linking</cell><cell>Linking, Segmentation, and Alignment</cell><cell><ptr target="#SA"/></cell></row>
<row><cell>msdescription</cell><cell>Manuscript Description</cell><cell><ptr target="#MS"/></cell></row>
<row><cell>namesdates</cell><cell>Names, Dates, People, and Places</cell><cell><ptr target="#ND"/></cell></row>
<row><cell>nets</cell><cell>Graphs, Networks, and Trees</cell><cell><ptr target="#GD"/></cell></row>
<row><cell>spoken</cell><cell>Transcribed Speech</cell><cell><ptr target="#TS"/></cell></row>
<row><cell>tagdocs</cell><cell>Documentation Elements</cell><cell><ptr target="#TD"/></cell></row>
<row><cell>tei</cell><cell>TEI Infrastructure</cell><cell><ptr target="#ST"/></cell></row>
<!--row><cell>terminology</cell><cell>terminology</cell><cell><ptr target="#TE"/></cell></row-->
<row><cell>textcrit</cell><cell>Text Criticism</cell><cell><ptr target="#TC"/></cell></row>
<row><cell>textstructure</cell><cell>Default Text Structure</cell><cell><ptr target="#DS"/></cell></row>
<row><cell>transcr</cell><cell>Transcription of Primary Sources</cell><cell><ptr target="#PH"/></cell></row>
<row><cell>verse</cell><cell>Verse</cell><cell><ptr target="#VE"/></cell></row>
</table>

</p>
<!--
<p>For RELAX NG and W3C each module generates a single schema fragment
with the same name as the module. For XML DTD fragments, however, some
modules generates two fragments: for example the <ident
type="module">analysis</ident> module generates fragments called
<ident type="schemafrag">analysis-decl</ident> and <ident
type="schemafrag">analysis</ident>. This is because the declarations
they contain are needed at different points in the creation of an XML
DTD. The fragment suffixed <ident>-decls</ident> will typically
contain additional class or macro declarations that complement those
provided by the present chapter; for technical reasons, these must be
available separately from the additional element and attribute
declarations contained by the main fragment.  </p>

--> <!-- moved to IM -->
</div>


<div type="div2" xml:id="STIN"><head>Defining a TEI Schema</head>

<p>To determine that an XML document is valid (as opposed to merely
well-formed), its structure must be checked against a schema, as
discussed in chapter <ptr target="#SG"/>. For a valid TEI document,
this schema must be a conformant TEI schema, as further defined in
chapter <ptr target="#CF"/>.  Local systems may allow their schema or
DTD to be implicit, but for interchange purposes the schema associated
with a document <emph>must</emph> be made explicit. </p>

<p>A TEI-conformant schema is a specific combination of TEI modules,
possibly also including additional declarations that modify the
element and attribute declarations contained by each module. The TEI
provides an application-independent way of specifying a TEI schema by
means of the <gi>schemaSpec</gi> element defined in chapter <ptr
target="#TD"/>. The same system may also be used to specify a schema
which extends the TEI by adding new elements explicitly, or by
reference to other XML vocabularies. In either case, the specification
may be processed to generate a formal schema, expressed in a variety
of specific schema languages, such as XML DTD language, RELAX NG, or
W3C Schema. These output schemas can then be used by an XML processor
such as a validator or editor to validate documents.</p>

<!--
<list>
<item>the ODD specification may be processed to generate
a schema document in whichever schema language the editor
supports</item>
<item>for an editor using DTD language, a DTD subset declaration
invoking the DTD fragments corresponding with the schema specification
may be produced, together with XML DTD code for any additional
modifications</item>
<item>for an editor using RELAX NG language, a schema referencing the
appropriate predefined RELAX NG patterns may be produced, together
with any additional definitions required to support
modifications</item>
</list>
</p>
<p>The schema fragments produced by the TEI are delivered in a
parameterised form which facilitates the second and third options
listed above. The recommended method of customization is however the
first. For blind interchange of TEI documents, it should be necessary
to supply no more than a complete ODD specification along with the
documents.
</p>




-->

<!-- foregoing removed at behest of DB and berlin council mtg -->

<div type="div3" xml:id="STINsimpleExample"><head>A Simple Customization</head>
<p>The simplest customization of the TEI scheme combines just the
four recommended modules mentioned above. In ODD format, it
looks like this:
<egXML xmlns="http://www.tei-c.org/ns/Examples">
<schemaSpec ident="TEI-minimal" start="TEI">
  <moduleRef key="tei"/>
  <moduleRef key="header"/>
  <moduleRef key="core"/>
  <moduleRef key="textstructure"/>
</schemaSpec>
</egXML></p>
<p>This schema specification contains references to each of the four
modules, identified by the <att>key</att> attribute on the
<gi>moduleRef</gi> element. The schema specification itself is also
given an identifier (<ident>TEI-minimal</ident>) and the start point, or
root element, is specified by means of the <att>start</att> attribute.
An ODD processor will generate an appropriate schema (which may be the XML DTD language, the ISO RELAX NG language,
or the W3C Schema language) from this set of declarations, which would then be
associated with the document instance by one of a number of different
mechanisms, as further described in chapter <ptr target="#SG"/><!-- somewhere --> 
Further information about the processing of an ODD specification is
given in <ptr target="#IM"/>.
</p>
<!--
<p>The same effect might be obtained by means of a RELAX NG
schema like the following:
<egXML xmlns="http://www.tei-c.org/ns/Examples">
include "tei.rnc" 
include "core.rnc"
include "header.rnc"
include "textstructure.rnc"
start = TEI 
</egXML>
which combines the declarations from the filenames specified to form a
schema with the given start point. </p>
<p>The same effect might be obtained in a DTD processing environment
by prefixing the document with a <term>DOCTYPE declaration</term> like the following:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<!DOCTYPE TEI
PUBLIC "-//TEI P5//DTD Main Document Type//EN" "tei.dtd" [
      <!ENTITY % TEI.header 'INCLUDE' >
      <!ENTITY % TEI.core 'INCLUDE' >
      <!ENTITY % TEI.textstructure 'INCLUDE' >
]>]]></egXML>
This uses an indirect method of nominating the DTD schema fragments
from which the DTD is to be constructed, based on the use of parameter
entities, as further discussed in section <ptr target="#STPE"/>.
</p> -->
</div>
<div type="div3" xml:id="STINlargerExample"><head>A Larger Customization</head>
<!-- does this belong here? -->
<p>These Guidelines introduce each of the modules making up the TEI
scheme one by one, and therefore, for clarity of exposition, each
chapter tends to focus on elements drawn from a single module. In reality, of
course, the markup of a text  will draw on elements taken from many
different modules, partly because texts are heterogenous objects, and
partly because encoders have different goals. Some examples of this
heterogeneity include:
<list type="bullets">
<item>when the text is a collection of other texts of different types
e.g. an anthology of prose, verse, and drama</item>
<item>when the text contains other smaller, embedded texts:  e.g. a poem
or song included in a prose narrative</item>
<item>when some sections of the text are written in one form, and others
in a different form:  e.g. a novel where some chapters are in prose,
others take the form of dictionary entries, and still others the form of
scenes in a play</item>
<item>when the encoded text includes detailed analytic annotation, for
example of rhetorical or linguistic features</item>
<item>when the encoded text combines  a literal transcription  with a diplomatic
edition of the same or different sources</item>
<item>when description of the text requires additional specialised metadata
elements, for example when describing manuscript material in detail</item> 
</list></p>
<!--
<item>when the text moves back and forth among forms not between
sections but within a single section:  e.g. mixed prose-and-verse forms
like many pastorals or like some portions of the Poetic Edda</item></list></p>-->

<p>The TEI provides mechanisms to support all of these and many other
use cases. The architecture permits elements and attributes from any
combination of modules to co-exist within a single schema. Within
particular modules, elements and attributes are provided to support
differing views of the <soCalled>granularity</soCalled> of a text, for
example:
<list type="bullets">
<item>a definition of a corpus or collection as a series of
<gi>TEI</gi>
documents, sharing a common TEI header (see chapter <ptr target="#CC"/>)</item>
<item>a definition of composite texts which combine optional front and
backmatter with a
group of collected texts,
themselves possibly composite (see section <ptr target="#DSGRP"/>)</item>
<item>an element for the representation of  <term>embedded
texts</term>, where one narrative appears to
<soCalled>float</soCalled> within another (see section <ptr target="#DSFLT"/>)</item></list></p>
<p>Subsequent chapters of these Guidelines describe in detail markup
constructs appropriate for these and many other possible features of
interest. The markup constructs can be combined as appropriate for any
given set of applications or project.</p> 

<p>For example, a project aiming to produce an ambitious digital
edition of a collection of manuscript materials, to include detailed
metadata about each source, digital images of the content, along with a detailed
transcription of each source, and a supporting biographical and
geographical database would need a schema combining several  modules,
as follows:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><schemaSpec ident="TEI-PROJECT" start="TEI">
  <moduleRef key="tei"/>
  <moduleRef key="header"/>
  <moduleRef key="core"/>
  <moduleRef key="textstructure"/>
  <moduleRef key="msdescription"/>
  <moduleRef key="transcr"/>
  <moduleRef key="namesdates"/>
</schemaSpec></egXML></p>

<p>Alternatively, a simpler schema might be used for a part of such a
project: those preparing the transcriptions, for example, might need
only elements from the <ident type="module">core</ident> and <ident
type="module">transcr</ident> modules, and might therefore  prefer to
use a simpler schema such as that
generated by the following:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><schemaSpec ident="TEI-TRANSCR" start="TEI">
  <moduleRef key="tei"/>
  <moduleRef key="core"/>
  <moduleRef key="textstructure"/>
  <moduleRef key="transcr"/>
</schemaSpec></egXML>
</p>

<p>The TEI architecture also supports more detailed customization
beyond the simple selection of modules. A schema may suppress elements
from a module, suppress some of their attributes, change their names
or even add new elements and attributes. Detailed discussion of the
kind of modification possible in this way is provided in <ptr
target="#MD"/> and conformance rules relating to their application are
discussed in <ptr target="#CF"/>. These facilities are available for
any schema language (though some features such as alternation of
attributes are not available in all languages). The ODD language also
makes it possible to combine TEI and non-TEI modules into a single
schema, provided that the non-TEI module is expressed using the RELAX
NG schema language (see further <ptr target="#ST-aliens"/>. </p>

</div>

</div>



<div type="div2" xml:id="STEC"><head>The TEI Class System</head>

<p>The TEI scheme distinguishes over four hundred different elements.
To aid comprehension, modularity, and modification, the majority of
these elements are formally classified in some way.  Classes are used
to express two distinct kinds of commonality among elements.  The
elements of a class may share some set of attributes, or they may
appear in the same locations in a content model.  A class is known as
an <term>attribute class</term> if its members share attributes, and
as a <term>model class</term> if its members appear in the same
locations. In either case, an element is said to <term>inherit</term>
properties from any classes of which it is a member.  Classes may have
subclasses and superclasses, and the properties of a superclass are
inherited by all members of its subclasses.
 </p>

<p>In the RELAX NG fragments which express the TEI scheme, attribute
and model classes are represented by patterns whose names begin with
<ident>att.</ident> or <ident>model.</ident> respectively. The same
names are used in the XML DTD fragments for the parameter entities
used to implement the class system.
 </p>

<p>In both cases, the <ident type="module">tei</ident> module provides
an appropriate initial declaration for the class, so that it can
subsequently be referenced, either by a subclass, or by someone
wishing to extend the class with a new element. In the TEI DTD
fragments, each class is fully defined by its associated parameter
entity declaration; in the RELAX NG schema fragment, each class is
incrementally defined as each element declaration modifies the initial
pattern provided by the TEI infrastructure module.</p>

<p>A basic understanding of the classes into which the TEI scheme is
organized is strongly recommended and is essential for any successful
customization of the system. </p>

</div>

<div type="div2" xml:id="STECAT"><head>Attribute Classes</head>

<p>An attribute class groups together elements which share some set of
common attributes.  Attribute classes are given names beginning
<code>att.</code> and are usually adjectival. For example, the members
of the class <ident type="class">att.naming</ident> have in common a
<att>key</att> attribute, which is inherited from their membership in
the class rather than individually defined for each element.  This
attribute is said to be defined by (or inherited from) the <ident
type="class">att.naming</ident> class. If another element were to be
added to the TEI scheme for which a similar <att>key</att> attribute
was considered useful, the simplest way to add it would be to make the
new element a member of the <ident type="class">att.naming</ident>
class. </p>

<p>The attributes provided by an attribute class are those specified
by the class itself, either directly, or by inheritance from another
class. For example, the attribute class <ident
type="class">att.pointing.group</ident> provides attributes
<att>domains</att> and <att>targFunc</att> to all of its members. This
class is however a subclass of the <ident
type="class">att.pointing</ident> class, from which its members also
inherit the attributes <att>type</att> and <att>evaluate</att>.
Members of the class <ident type="class">att.pointing</ident> will
thus have these two attributes, while members of the class <ident
type="class">att.pointing.group</ident> will have all four.</p>

<p>Most attribute classes are defined within the <ident
type="module">tei</ident> infrastructural module and
are thus globally available. Some classes are specific to particular
modules and thus defined in other chapters. Attributes defined by such
classes will not be available unless the module concerned is included
in a schema. </p>

<p>Note that some modules define superclasses of an existing
infrastructural class.  For example, the global attribute class
<ident type="class">att.divLike</ident> makes attributes
<att>org</att>, <att>uniform</att>, and <att>sample</att> available,
while the <ident type="class">att.metrical</ident> class, which is
specific to the <ident type="module">verse</ident> module, provides
attributes <att>met</att>, <att>real</att>, and
<att>rhyme</att>. Because <ident type="class">att.metrical</ident> is
defined as a superclass of <ident type="class">att.divLike</ident>,
all six of these attributes are available to <ident
type="class">att.metrical</ident> elements; the att.metrical
declaration adds its three attributes to the three already defined by
att.divLike when the <ident type="module">verse</ident> module is
included in a schema. If, however, this module is not included in a
schema the <ident type="class">att.divLike</ident> elements supplies
only the three attributes first mentioned. </p>


<p>Attributes specific to particular modules are documented along with
the relevant module rather than in the present chapter. One particular
attribute class, known as <ident type="class">att.global</ident>, is
common to all modules, and is therefore described in some detail in
the next section. This description is followed by a reference list of
all other attribute classes.
</p>

<div type="div2" xml:id="STGA"><head>Global Attributes</head>

<p>The following attributes are defined for every TEI element.

<specList><specDesc key="att.global"
atts="xml:id n xml:lang rend rendition"/></specList>
 </p>

<!--<p>Some modules (e.g. those for transcription, linking, and analysis)
define other global attributes; these additional attributes are
documented along with the module concerned; see also section <ptr
target="#STECAT"/>.
 </p>-->
<p>These attributes are optionally available for any TEI element; none
of them is required. <!--may be given values for <att>xml:id</att>, <att>n</att>,
<att>xml:lang</att>, <att>rend</att>, or <att>rendition</att>, simply by
specifying values for these attributes.
The following two examples convey the same information about the text:
that the material transcribed occurs within a <gi>p</gi> element
(paragraph).  They differ only in that the second provides an identifier
for the paragraph, to which other elements (e.g. notes or hypertext
links) can conveniently refer.
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p>If to do were as easy as to know what were
good to do, chapels had been churches and poor men's cottages
princes' palaces.  It is a good divine that follows his own
instructions ...</p></egXML>
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p xml:id="mv1.2.5">If to do were as easy as to know what were
good to do, chapels had been churches and poor men's cottages
princes' palaces.  It is a good divine that follows his own
instructions ...</p></egXML>-->
<!-- Merchant of Venice, I.ii, speech 5 (Portia)              -->
</p>
  <p>The value supplied for the <att>xml:id</att> attribute must be a legal
	<ident type="kw">name</ident>, as defined in the World Wide Web
	Consortium's XML Recommendation. This means that it must
	begin with a letter,  or the underscore character
	(<q>_</q>), and contain no characters other than letters, digits,
	hyphens, underscores, full
	stops, and certain combining and extension characters.<note place="foot">The colon is also by default a
	valid name character; however, it has a  specific
	purpose in XML (to indicate namespace prefixes), and may not
	therefore be used in any other way within a name.</note></p>
  <p>In XML names (and thus the values of <att>xml:id</att> in an XML TEI
	document) upper and lower case letters are distinguished, and
	thus <mentioned>partTime</mentioned> and
	<mentioned>parttime</mentioned> are two distinctly different
	names, and could (though perhaps unwisely) be used to denote two
	different element types.</p>
  <p>If two elements are given the same identifier,a validating XML parser will
	signal a syntax error. The following example, therefore, is
	<emph>not</emph> valid:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[<p xml:id="PAGE1">]]><q>What's it going to be then, eh?</q><![CDATA[</p>
]]><p xml:id="PAGE1">There was me, that is Alex, and my three droogs,
that is Pete, Georgie, and Dim, ... </p></egXML>
<!-- Clockwork Orange, opening -->
</p>
<p>For a discussion of methods of providing unique identifiers for
elements, see section <ptr target="#CORS2"/>.</p>
<p>The <att>n</att> attribute also provides an identifying name or number for an
element, but in this case the information need not be a legal
<att>xml:id</att> value.  Its value may be any string of characters;
typically it is a number or other similar enumerator or label.  For
example, the numbers given to the items of a numbered list may be
recorded with the <att>n</att> attribute; this would make it possible to
record errors in the numeration of the original, as in this list of
chapters, transcribed from a faulty original in which the number 10 is
used twice, and 11 is omitted:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><list type="ordered">
  <item n="1">About These Guidelines</item>
  <item n="2">A Gentle Introduction to SGML</item>
  <item n="9">Verse</item>
  <item n="10">Drama</item>
  <item n="10">Spoken Materials </item>
  <item n="12">Print Dictionaries</item>
</list></egXML>
The <att>n</att> attribute may also be used to record non-unique names
associated with elements in a text, possibly together with a unique
identifier as in the following example:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><div type="Book"
						     n="One"
						     xml:id="TXT0101"><!-- ....-->
<div type="stanza" n="xlii">
<!-- ... -->
</div>
</div></egXML>
 </p>
<p>As noted above there is no requirement to record a value for either
the <att>xml:id</att> or the <att>n</att> attribute. Any XML processor
can identify the sequential position of one element within another in
an XML  document without any additional tagging. An encoding in
which each line of a long poem is explicitly labelled with its numerical
sequence such as
the following
<egXML xmlns="http://www.tei-c.org/ns/Examples"><l n="1"><!-- ....--></l>
<l n="2"><!-- ....--></l>
<l n="3"><!-- ....--></l>
<!-- ....-->
<l n="100"><!-- ....--></l>
</egXML> is therefore probably redundant.</p>




<p>The <att>xml:lang</att> attribute indicates the language, writing system,
and character set associated with a given element and all its contents.
If it is not specified, the value is inherited from that of the
immediately enclosing element.  As a rule, therefore, it is simplest to
specify the base language of the text on the <gi>TEI</gi> element, and
allow most elements to take the default value for <att>xml:lang</att>; the
language of an element then need be explicitly specified only for
elements in languages other than the base language.
 </p>
<p>The values used for the <att>xml:lang</att> attribute must be
constructed in a particular way, using values from standard lists. See
further <ptr target="#CHSH"/>.</p>
<p>The following two encodings convey the same information about the
language of the text, since in the first the <att>xml:lang</att> attributes
on the <gi>emph</gi> elements specify the same value as that on the
parent <gi>p</gi> element, while in the second they inherit that value
without specifying it.
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p xml:lang="en"> ... Both parties deprecated war, but one of
 them would <emph xml:lang="en">make</emph> war rather than let
 the nation survive, and the other would <emph xml:lang="en">accept
 </emph> war rather than let it perish, and the war came.</p></egXML>
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p xml:lang="en"> ... Both parties deprecated war, but one of
 them would <emph>make</emph> war rather than let
 the nation survive, and the other would <emph>accept</emph>
 war rather than let it perish, and the war came.</p></egXML>
<!-- Lincoln's Second Inaugural Address, 4 March 1865, rpt.   -->
	<!-- (from Richardson, ed., Messages and Papers, 6:276ff) in  -->
	<!-- H. S. Commager, ed., Documents of American History, 5th  -->
	<!-- ed.  (New York:  Appleton-Century-Crofts, 1949), p.      -->
	<!-- 442.                                                     -->
 </p>
<p>In the following example, by contrast, the <att>xml:lang</att> attribute
on the <gi>term</gi> element must be given if we wish to record the fact
that the technical terms used are Latin rather than English; no
<att>xml:lang</att> attribute is needed on the <gi>q</gi> element, by
contrast, because it is in the same language as its parent.  It is
strongly recommended that all language shifts in the source be
explicitly identified by use of the <att>xml:lang</att> attribute, as
described in chapter <ptr target="#CH"/>.
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p xml:lang="en">The constitution declares <q>that no bill of attainder
or <term xml:lang="la">ex post facto</term> law shall be passed.</q> ... </p></egXML>
<!-- Marbury v. Madison, 1 Cranch, 137 (1803), rpt. in H. S.  -->
	<!-- Commager, ed., Documents of American History, 5th ed.    -->
	<!-- (New York:  Appleton-Century-Crofts, 1949), p. 192.      -->
</p>
<p>As further discussed in section <ptr target="#CHSH"/>, additional
information  about a particular language
may be supplied in the <gi>language</gi> element within the header (see
section <ptr target="#HD41"/>).</p>
<p>The <att>rend</att> attribute is used to give information about the
physical presentation of the text in the source.  In the following
example, it is used to indicate that both the emphasized word and the
proper name are printed in italics:
<egXML xmlns="http://www.tei-c.org/ns/Examples"><p> ... Their motives <emph rend="italics">might</emph> be
 pure and pious; but he was equally alarmed by his knowledge
 of the ambitious <name rend="italics">Bohemond</name>, and
 his ignorance of the Transalpine chiefs: ...</p></egXML>
<!-- Gibbon, Decline and Fall, chapter 58, para beginning     -->
	<!-- 'In some Oriental tale I have read ...', p. 391 of       -->
	<!-- Britannica edition.                                      -->
	<!--  ... played fast and loose with by LB for pedagogic purposes -->
	<!-- Shame, shame.                                            -->
If all or most <gi>emph</gi> and <gi>name</gi> elements are rendered in
the text by italics, it will be more convenient to register that fact in
the TEI header once and for all and specify a <att>rend</att> value
only for any elements which deviate from the usual rendition.
 </p>
<p>The contents of the <att>rend</att> attribute are free text.  In any
given project, encoders are advised to settle on a standard vocabulary
with which to describe typographic or manuscript rendition of the
text.</p>
<p>The  <gi>rendition</gi>
element defined in <ptr target="#HD57"/> may be used to hold such
descriptions, expressed in free text, or using a formal language. A
<gi>rendition</gi> element can then be associated with any element,
either by default, or by means of the global <att>rendition</att>
attribute. For example:
<egXML xmlns="http://www.tei-c.org/ns/Examples"> 
<!-- define italic style using CSS -->
   <rendition xml:id="IT" scheme="css">text-style: italic</rendition>
<!-- set italic style as default for the emph and hi elements -->
   <tagUsage gi="emph" render="#IT"/>
   <tagUsage gi="hi" render="#IT"/>
<!-- indicate that a specific p element is also in italic style -->
   <p rendition="#IT"/>
</egXML>
</p>
<p>The <att>rendition</att> attribute always points to one or more
<gi>rendition</gi> elements, each of which defines some aspect of the
rendering or appearance of the text in its original form. These details may be
described using a formal language, such as Cascading Style Sheets (CSS)
or Extensible Stylesheet Language Formatting Objects (XSL-FO); in an
original formal language developed for a specific project; or
informally in running prose. Although languages such as CSS and XSL-FO
are generally used to describe document output to screen or print, they
nonetheless provide formal and precise mechanisms for describing the
appearance of many source documents, especially print documents, but
also many aspects of manuscript documents. For example, both CSS and
XSL-FO provide mechanisms for describing font families, weight, and
styles; character and line spacing; and so on.</p>
<p>If both <att>rendition</att> and <att>rend</att> attributes are
provided for a given element, the latter always takes precedence.  The
combination of the global <att>rendition</att> and <att>rend</att>
attributes provide a robust system for describing rendition
information for source documents. The global <att>rendition</att>
attribute is analogous to the X/HTML <att>class</att> attribute, which
references style declarations in a Cascading Style Sheet. The global
<att>rend</att> attribute is analogous to the X/HTML <att>style</att>
attribute, which provides a mechanism for embedding inline rendition
information at the point of use within a document. Note that, in either
case, the TEI attributes describe the rendition or appearance of
the source document, <emph>not</emph> intended output renditions.  </p></div>


<div xml:id="STattclass"><head>Other Attribute Classes</head>

<p>
<!-- shd be generated -->

<table xml:id="tab-atts"><row role="label"><cell>class</cell><cell>function</cell><cell>superclass</cell></row>
<row><cell>att.ascribed</cell><cell>provides attributes for elements representing speech or action that can be ascribed to a specific individual.</cell><cell/></row>
<!--<row><cell>att.authorialIntervention</cell><cell>provides attributes describing the nature of an authorial intervention.</cell><cell/></row>-->
<row><cell>att.damaged</cell><cell>provides attributes describing the nature of any physical
  damage affecting a reading. </cell><cell></cell></row>
<row><cell>att.datable</cell><cell>provides attributes for normalization of elements that contain datable events.</cell><cell>att.datable.w3c  att.datable.iso</cell></row>
<row><cell>att.datable.w3c</cell><cell>provides attributes for normalization of elements that contain datable events.</cell><cell/></row>
<row><cell>att.declarable</cell><cell>provides attributes for those elements in the TEI Header which may be independently selected by means of  the specialpurpose decls attribute.</cell><cell/></row>
<row><cell>att.declaring</cell><cell>provides attributes for elements which may be independently associated with a particular declarable element within the header, thus overriding the inherited default for that element.</cell><cell/></row>
<!-- <row><cell>att.dimensions</cell><cell>provides attributes which qualify a measurement of the lenght of a dimension of an object.</cell><cell/></row> -->
<row><cell>att.divLike</cell><cell>provides a set of attributes common to all elements which behave in the same way as divisions.</cell><cell>att.metrical  </cell></row>
<row><cell>att.duration</cell><cell>provides attributes for normalization of elements that contain temporal durations.</cell><cell>att.duration.w3c  att.duration.iso</cell></row>
<row><cell>att.duration.w3c</cell><cell>provides attributes for normalization of elements that contain temporal durations.</cell><cell/></row>
<row><cell>att.editLike</cell><cell>provides attributes describing the nature of a encoded scholarly intervention or interpretation of any kind.</cell><cell/></row>
<row><cell>att.global</cell><cell>provides a set of attributes common to all elements in the TEI encoding scheme.</cell><cell>att.global.linking  att.global.analytic  att.global.facs</cell></row>
<row><cell>att.handFeatures</cell><cell>provides attributes describing aspects of the hand in which a
  manuscript is written.</cell><cell></cell></row>
<row><cell>att.internetMedia</cell><cell>provides attributes for specifying the type of a computer resource using a standard taxonomy</cell></row>
<row><cell>att.interpLike</cell><cell>provides attributes for elements which represent a formal analysis or interpretation.</cell><cell/></row>
<row><cell>att.measurement</cell><cell>provides attributes to represent a regularized or normalized measurement.</cell><cell/></row>
<row><cell>att.naming</cell><cell>provides attributes common to  elements which refer to named persons, places, organizations etc.</cell><cell/></row>
<row><cell>att.placement</cell><cell>provides attributes for describing where on the source page or object a textual element appears.</cell><cell/></row>
<row><cell>att.segLike</cell><cell>provides attributes for elements used for arbitrary segmentation. </cell><cell>att.metrical  </cell></row>
<row><cell>att.spanning</cell><cell>provides attributes for elements which delimit a span of text by pointing mechanisms rather than by enclosing it.</cell><cell/></row>
<row><cell>att.tableDecoration</cell><cell>provides attributes used to decorate rows or cells of a table.</cell><cell/></row>
<row><cell>att.timed</cell><cell>provides a set of attributes common to those elements which have a duration in time, expressed either absolutely or by reference to an alignment map.</cell><cell/></row>
<row><cell>att.transcriptional</cell><cell>provides attributes specific to elements used when
  transcribing manuscript or similar sources. </cell><cell/></row>
<row><cell>att.translatable</cell><cell>provides attributes used to  indicate the status of a translatable
portion of an ODD document. </cell><cell/></row>
<row><cell>att.typed</cell><cell>provides generic attributes which can be used to classify or subclassify elements in any way. </cell><cell/></row>
</table>
</p>


<specGrp xml:id="DSTECAT" n="Attribute classes">
&att.ascribed;
<!--&att.authorialIntervention;--> <!-- now renamed att.transcriptional -->
&att.damaged;
&att.datable.w3c;
&att.datable;
&att.declarable; <!-- move to HD or CC? -->
&att.declaring;
&att.divLike;
&att.duration.w3c; 
&att.duration; 
&att.editLike;
&att.global;
&att.handFeatures;
&att.internetMedia;
&att.interpLike; <!-- shd move to analysis-decl? -->
&att.measurement;
&att.naming;
&att.placement;
&att.segLike;
&att.spanning;
&att.tableDecoration; <!-- move to FT? -->
&att.timed;   <!-- move to TS? -->
&att.transcriptional;
&att.translatable;
&att.typed;
</specGrp>

</div>
</div>

<div type="div2" xml:id="STECCM"><head>Model Classes</head>

<p>When the members of a class are structurally similar and can appear
at the same kinds of structural locations in the document, they are
said to constitute a <soCalled>model class</soCalled>. Like attribute
classes, model classes may have subclasses or superclasses.  Just as
elements inherit from a class the ability to appear in certain
locations of a document (wherever the class can appear), so all
members of a subclass inherit the ability to appear wherever any
superclass can appear. </p>



<p>The TEI class system is structured around the following threefold
division of elements:
<list type="gloss"><label><term>chunks</term> </label>
<item>elements such as paragraphs and other
paragraph-level elements, which can appear directly within texts or
within text subdivisions (i.e. <gi>div</gi> elements), but not within
other chunks</item><label><term>phrase-level elements</term> </label>
<item>elements such as
highlighted phrases, book titles, or editorial corrections which can
occur only within chunks (paragraphs or paragraph-level elements), but
not between them (and thus cannot appear directly within a
<gi>div</gi>)<note place="foot">Note that in this context, <term>phrase</term> means
any string of characters, and can apply to individual words, parts of
words, and groups of words indifferently; it does not refer only to
linguistically motivated phrasal units.  This may cause confusion for
readers accustomed to applying the word in a more restrictive sense.</note></item>
<label><term>inter-level elements</term></label>
<item>elements such as lists,
notes, quotations, etc. which can appear either between chunks (as
children of a <gi>div</gi>) or within them</item></list>
 </p>
<p>Together the two sets of <term>chunks</term> and <term>inter-level
elements</term> make up the set of:
<list type="gloss"><label><term>text components</term> </label>
<item>elements which can appear
directly within texts or text divisions; also called simply
<term>components</term> or <soCalled>component-level elements</soCalled></item></list>
In general, the body of any text comprises a series of components,
optionally grouped into <gi>div</gi> elements.
 </p>
<p>Some elements belong to none of these classes; these include
high-level structural elements like <gi>TEI</gi> and
<gi>group</gi> as well as some specialized elements which appear only
within particular structures (like <gi>analytic</gi>,
<gi>monographic</gi>, and <gi>series</gi>).  The majority of elements
found in normal running text, however, are assigned  to
one or the other of these classes.
 </p>
</div>

<div type="div3" xml:id="STECLO"><head>Low-Level Element Classes</head>
<p>The following low-level classes
group together sets of semantically or structurally similar elements.
These classes may include both elements in the core and elements
declared in particular modules; a reference is given at least to the
relevant section on the core tags.
 </p>
<!--<p>The following are phrase-level element classes:
<specList>
<specDesc key="model.addressLike"/>
<specDesc key="model.biblLike"/>
<specDesc key="model.dateLike"/>
<specDesc key="model.egLike"/>
<specDesc key="model.global"/>
<specDesc key="model.graphicLike"/>
<specDesc key="model.hiLike"/>
<specDesc key="model.emphLike"/>
<specDesc key="model.headLike"/>
<specDesc key="model.labelLike"/>
<specDesc key="model.listLike"/>
<specDesc key="model.measureLike"/>
<specDesc key="model.noteLike"/>
<specDesc key="model.pPart.data"/>
<specDesc key="model.pPart.editorial"/>
<specDesc key="model.pPart.msdesc"/>
<specDesc key="model.pPart.transcriptional"/>
<specDesc key="model.ptrLike"/>
<specDesc key="model.ptrLike.form"/>
<specDesc key="model.qLike"/>
<specDesc key="model.segLike"/>
</specList>
</p>-->

<p>

</p>
</div>
<div type="div3" xml:id="STECHI"><head>High-Level Element Classes</head>
<p>The following element classes are used to implement the threefold
structural distinction among phrases, chunks, and intermediate elements
discussed above in section <ptr target="#STECCM"/>.  In this terminology,
<term>chunk</term>s (or <term>chunk elements</term>) are elements which
can occur only in chunk-level sequences (e.g. between but not within
paragraphs); <term>inter-level elements</term> can occur either within
chunks (at phrase-level) or between chunks (e.g. at paragraph-level),
and <term>phrase-level elements</term> can occur only at phrase level,
within chunks (e.g. within but not between paragraphs).
 </p>
<p>The element class <ident type="class">model.common</ident> includes all
component-level (chunk- and inter-level) elements <!-- common to more than
one base.  It is used in implementing the combined bases described in
section <ptr target="#STECMX"/>.-->
  </p>

</div>
<div type="div3" xml:id="STECMK"><head>Elements Marked for Text Type</head>
<p>The following element classes are used to group together
component-level elements which are allowed only in texts of a particular
type (i.e. texts using a specific module).
<!--<specList>
<specDesc key="model.divPart.spoken"/>
<specDesc key="model.frontPart.drama"/>
<specDesc key="model.entryLike"/>
</specList>
--> </p>
<p>Declarations for these module-specific element classes are included
in a separate <ident type="module">-decls</ident> schema fragment when
XML DTDs are used. In  RELAX NG  schema fragments, the corresponding
declarations are given at the start of the same schema fragment as the
other declarations. </p></div>

<div type="div3" xml:id="STECMI"><head>Miscellaneous Content-Model Classes</head>
<p>The following element classes occupy specific places in content
models; most are relevant only when certain modules are selected
</p></div>
<div><head>List of model classes </head>
<p>
<specList>
<specDesc key="model.addrPart"/>
<specDesc key="model.addressLike"/>
<specDesc key="model.applicationLike"/>
<specDesc key="model.assertLike"/>
<specDesc key="model.biblLike"/>
<specDesc key="model.biblPart"/>
<specDesc key="model.blockLike"/>
<specDesc key="model.castItemPart"/>
<specDesc key="model.catDescPart"/>
<specDesc key="model.choicePart"/>
<specDesc key="model.common"/>
<specDesc key="model.complexVal"/>
<specDesc key="model.dateLike"/>
<specDesc key="model.div1Like"/>
<specDesc key="model.div2Like"/>
<specDesc key="model.div3Like"/>
<specDesc key="model.div4Like"/>
<specDesc key="model.div5Like"/>
<specDesc key="model.div6Like"/>
<specDesc key="model.div7Like"/>
<specDesc key="model.divBottom"/>
<specDesc key="model.divBottomPart"/>
<specDesc key="model.divGenLike"/>
<specDesc key="model.divLike"/>
<specDesc key="model.divPart"/>
<specDesc key="model.divPart.spoken"/>
<specDesc key="model.divTop"/>
<specDesc key="model.divTopPart"/>
<specDesc key="model.divWrapper"/>
<specDesc key="model.editorialDeclPart"/>
<specDesc key="model.egLike"/>
<specDesc key="model.emphLike"/>
<specDesc key="model.encodingPart"/>
<specDesc key="model.entryLike"/>
<specDesc key="model.entryParts"/>
<specDesc key="model.entryParts.top"/>
<specDesc key="model.featureVal"/>
<specDesc key="model.formPart"/>
<specDesc key="model.frontPart"/>
<specDesc key="model.frontPart.drama"/>
<specDesc key="model.gLike"/>
<specDesc key="model.global"/>
<specDesc key="model.global.edit"/>
<specDesc key="model.global.meta"/>
<specDesc key="model.glossLike"/>
<specDesc key="model.gramPart"/>
<specDesc key="model.graphicLike"/>
<!--specDesc key="model.handDescPart"/-->
<specDesc key="model.headLike"/>
<specDesc key="model.headerPart"/>
<specDesc key="model.hiLike"/>
<specDesc key="model.hilighted"/>
<specDesc key="model.imprintPart"/>
<specDesc key="model.inter"/>
<specDesc key="model.inter.spoken"/>
<specDesc key="model.lLike"/>
<specDesc key="model.lPart"/>
<specDesc key="model.labelLike"/>
<specDesc key="model.limitedPhrase"/>
<specDesc key="model.listLike"/>
<specDesc key="model.measureLike"/>
<specDesc key="model.milestoneLike"/>
<specDesc key="model.morphLike"/>
<specDesc key="model.msItemPart"/>
<specDesc key="model.nameLike"/>
<specDesc key="model.nameLike.agent"/>
<specDesc key="model.noteLike"/>
<specDesc key="model.oddDecl"/>
<specDesc key="model.oddRef"/>
<specDesc key="model.orgStateLike"/>
<specDesc key="model.pLike"/>
<specDesc key="model.pLike.front"/>
<specDesc key="model.pPart.data"/>
<specDesc key="model.pPart.edit"/>
<specDesc key="model.pPart.editorial"/>
<specDesc key="model.pPart.msdesc"/>
<specDesc key="model.pPart.transcriptional"/>
<specDesc key="model.persEventLike"/>
<specDesc key="model.persNamePart"/>
<specDesc key="model.persStateLike"/>
<specDesc key="model.persTraitLike"/>
<specDesc key="model.personLike"/>
<specDesc key="model.personPart"/>
<specDesc key="model.phrase"/>
<specDesc key="model.physDescPart"/>
<specDesc key="model.placeEventLike"/>
<specDesc key="model.placeLike"/>
<specDesc key="model.placeNamePart"/>
<specDesc key="model.placeStateLike"/>
<specDesc key="model.placeTraitLike"/>
<specDesc key="model.profileDescPart"/>
<specDesc key="model.ptrLike"/>
<specDesc key="model.ptrLike.form"/>
<specDesc key="model.publicationStmtPart"/>
<specDesc key="model.qLike"/>
<specDesc key="model.quoteLike"/>
<specDesc key="model.rdgLike"/>
<specDesc key="model.rdgPart"/>
<specDesc key="model.recordingPart"/>
<specDesc key="model.resourceLike"/>
<specDesc key="model.respLike"/>
<specDesc key="model.segLike"/>
<specDesc key="model.settingPart"/>
<specDesc key="model.singleVal"/>
<specDesc key="model.sourceDescPart"/>
<specDesc key="model.specDescLike"/>
<specDesc key="model.stageLike"/>
<specDesc key="model.textDescPart"/>
<specDesc key="model.titlepagePart"/>
<specDesc key="model.xmlPhrase"/>
</specList>
 </p>


<!--
<div type="div3" xml:id="STECSD">
<head>Structural Divisions</head>

<p>The structure of a text body is often divided into sections;
model classes are provided to specify these:

<specList>
</specList>
</p>
-->

<!-- all model class declarations: nb order is critical -->



<!-- inline things -->
&model.nameLike.agent;
&model.segLike;
&model.hiLike;
&model.emphLike;
&model.highlighted;
&model.dateLike;
&model.measureLike;
&model.egLike;
&model.graphicLike;
&model.pPart.msdesc;  <!-- model.pPartMsdesc -->
&model.pPart.editorial; 
&model.pPart.transcriptional;
&model.pPart.edit; 
&model.ptrLike;  
&model.lPart;
&model.global.meta; 
&model.milestoneLike; 
&model.gLike;
&model.oddDecl;
&model.oddRef;
&model.xmlPhrase;
&model.specDescLike;

<!-- inter level -->

&model.biblLike;
&model.handDescPart;
&model.headLike;
&model.labelLike;
&model.listLike;
&model.noteLike;
&model.pLike;  <!-- used by model.divPart -->
&model.stageLike;
&model.complexVal;
&model.singleVal;
&model.entryParts;
&model.entryParts.top;
&model.global.edit;
&model.divPart;
&model.blockLike;
&model.persTraitLike;
&model.persStateLike;
&model.persEventLike;
&model.assertLike;
&model.personLike;
&model.personPart;

&model.placeTraitLike;
&model.placeStateLike;
&model.placeEventLike;

&model.publicationStmtPart;
&model.glossLike;
&model.quoteLike;
&model.qLike;
&model.rdgLike;
&model.respLike;
&model.divWrapper;
&model.divTopPart;
&model.divTop;
&model.frontPart.drama;
&model.pLike.front;
&model.divBottomPart;
&model.divBottom;
&model.titlepagePart;
&model.msItemPart;
&model.choicePart;
&model.lLike;
&model.recordingPart;
&model.imprintPart;
&model.catDescPart;

&model.settingPart;
&model.textDescPart;
&model.castItemPart;
&model.physDescPart;
<!--/specGrp-->

<specGrp xml:id="DSTECLO-1" n="level 1 classes">
<!--<p>These classes refer only to primitive lowlevel classes or to elements</p>-->
&model.addressLike;
&model.nameLike;
&model.global;
&model.featureVal;
<!-- &model.common wuz ere;-->
&model.biblPart;
&model.frontPart;
</specGrp>
<specGrp xml:id="DSTECLO-2" n="level 2 classes">
<!--<p>These classes refer only to level 1 or to primitive lowlevel
classes or to elements</p>-->
&model.addrPart; 
&model.pPart.data;
&model.inter;  
&model.common; <!-- needs model.inter -->
</specGrp>

<specGrp xml:id="DSTECHI" n="Common high-level classes">
<!-- model.phrase--> &model.phrase;&model.limitedPhrase;
</specGrp>


&model.divLike;
&model.divGenLike;
&model.div1Like;
&model.div2Like;
&model.div3Like;
&model.div4Like;
&model.div5Like;
&model.div6Like;
&model.div7Like;

</div>



<div type="div2" xml:id="STmacros"><head>Macros</head>

<p>The <ident type="module">tei</ident> module also declares a number
of <term>macros</term>, or shortcut names for frequently occurring
parts of other declarations. These are used in two ways in the TEI
scheme: to stand for frequently-encountered content models, or parts
of content models (<ptr target="#STECST"/>); and to stand for
attribute datatypes (<ptr target="#DTYPES"/>). Macros are implemented
as patterns in the RELAX NG schema fragments, and as parameter
entities in the XML DTD fragments.</p>


<div type="div3" xml:id="STECST"><head>Standard Content Models</head>
<p>As far as possible, the TEI schemas use the following set of
frequently-encountered content models to help achieve consistency among
different elements.
<specList>
<specDesc key="macro.fileDescPart"/>
<specDesc key="macro.glossSeq"/>
<specDesc key="macro.paraContent"/>
<specDesc key="macro.limitedContent"/>
<specDesc key="macro.phraseSeq"/>
<specDesc key="macro.phraseSeq.limited"/>
<specDesc key="macro.schemapattern"/>
<specDesc key="macro.specialPara"/>
<specDesc key="macro.xtext"/>
</specList>
</p>



<specGrp>
&macro.paraContent;
&macro.limitedContent;
&macro.phraseSeq;
&macro.phraseSeq.limited;
&macro.specialPara;
&macro.xtext;
&macro.fileDescPart;
&macro.glossSeq;

</specGrp>
 </div>
<div type="div3" xml:id="DTYPES"><head>Datatype Macros</head>
<p>The values which attributes may take in a TEI schema are defined,
for the most part, by reference to a TEI <term>datatype</term>. Each
such datatype is defined in terms of other primitive datatypes (for
the most part defined by the W3C Schema language <!-- need proper
reference-->), literal values, or other datatypes. This indirection
makes it possible for a TEI application to set constraints either
globally or in individual cases, by redefining the datatype definition
or the reference to it respectively. In some cases, the TEI datatype
includes additional usage constraints which cannot be enforced by
existing schema languages, although a TEI-compliant processor should
attempt to validate them (see further discussion in chapter <ptr target="#CF"/>). </p>
<p>Where literal values or name tokens are used in a datatype
definition, an associated value list supplies definitions for the
significance of suggested or (in the case of closed lists) all
possible values.</p>
<!-- but can we put a valList in a macroSpec ? -->
<p>TEI-defined datatypes may be grouped into those which define
normalised values for numeric quantities or probabilities, those which
define various kinds of short-hand codes or keys, and those which
define pointers or links. </p>

<p>The following datatypes are used for attributes which are intended
to hold normalized values of various kinds. First, expressions of
quantity or probability:
<specList>
<specDesc key="data.certainty"/> 
<specDesc key="data.probability"/>
<specDesc key="data.numeric"/>
<specDesc key="data.count"/>
</specList>
</p>

<p>Examples of attributes using the data.probability datatype include
<att>degree</att> on <gi>damage</gi> or <gi>certainty</gi>;
<att>scale</att> on <gi>graphic</gi>; examples of <name
type="datatype">data.numeric</name> include <att>quantity</att> on
members of the <ident type="class">att.measurement</ident> class or
<att>value</att> on <gi>numeric</gi>; examples of <name
type="datatype">data.count</name> include <att>cols</att> on
<gi>cell</gi> and <gi>table</gi>.</p>

<specGrp xmlns:rng="http://relaxng.org/ns/structure/1.0" xml:id="DTYPES-1" n="Numeric Datatypes">
&data.certainty; 
&data.probability;
&data.numeric;
&data.count;
</specGrp>

<p>Next, the datatypes used for attributes which are intended to hold
normalized dates or times, durations, or truth values:
<specList>
<specDesc key="data.duration.w3c"/>
<specDesc key="data.temporal.w3c"/>
<specDesc key="data.truthValue"/>
<specDesc key="data.xTruthValue"/>
<specDesc key="data.language"/>
<specDesc key="data.sex"/>
</specList>
</p>

<p>Note that in each of these cases the values used are those
recommended by existing international standards: ISO 8601 in the case
of duration; ISO 8601 as profiled by <title>XML Schema Part 2:
Datatypes Second Edition</title> in the case of time and date; W3C
Schema datatypes in the case of truth values; RFC 3066 in the case of
language; and ISO 5218 in the case of sex.</p>

<specGrp xmlns:rng="http://relaxng.org/ns/structure/1.0" xml:id="DTYPES-2" n="Normalised Datatypes">
&data.temporal.w3c;
&data.duration.w3c;
&data.truthValue;
&data.xTruthValue;
&data.language;
&data.sex;
</specGrp>

<p>The following datatypes have more specialised uses:
<specList>
<specDesc key="data.outputMeasurement"/>
<specDesc key="data.namespace"/>
<specDesc key="data.pattern"/> <!-- only one usage -->
<specDesc key="data.pointer"/>
</specList>
</p>
<specGrp xmlns:rng="http://relaxng.org/ns/structure/1.0" xml:id="DTYPES-3" n="Notation and pointer datatypes">
&data.namespace;
&data.outputMeasurement;
&data.pattern;
&data.pointer;
</specGrp>

<p>By far the largest number of TEI attributes have values which are
coded values or names of some kind. These values may be constrained or
defined in a number of different ways, each of which is given a
different name, as follows:
<specList>
<specDesc key="data.key"/> <!-- 2 uses -->
<specDesc key="data.word"/>
<specDesc key="data.name"/>
<specDesc key="data.enumerated"/>
<specDesc key="data.code"/>
</specList>
</p>

<p>Attributes such as <att>key</att> of <gi>persName</gi> and other
members of the <ident type="class">att.naming</ident> class are of
type <ident type="datatype">data.key</ident>. They are used to supply
an externally-defined identifier, such as a database key or
filename. Because such identifiers are externally-defined, no
constraints are placed on their possible values: and any string of
Unicode characters may be used. Any constraints on their values, such
as the rules for constructing a valid database key in a particular
system, may be documented within the TEI Header but cannot be
enforced.</p>

<p>Attributes of type <ident type="datatype">data.word</ident>, such
as <att>age</att> on <gi>person</gi> are used to supply an identifier
expressed as any kind of single token or word. The TEI places a few
constraints on the characters which may be used for this purpose: only
Unicode characters classified as letters, digits, punctuation
characters, or symbols can appear in an attribute value of this
kind. Note in particular that such values cannot include whitespace
characters. Legal values include <val>cholmondeley</val>,
<val>t</val>, <val>1234</val>, <val>e_content</val>, or
<val>xml:id</val>, but not <val>grand wazoo</val>. Attributes of this
kind are sometimes used to associate (by co-reference) elements of
different types.</p>

<p>Attributes of type <ident type="datatype">data.name</ident> are
also words in this sense, but they have the additional constraint that
they must be legal XML identifiers, as defined by the XML 1.0
specification. As such, they may not begin with digits or punctuation
characters. Legal identifiers include <val>cholmondeley</val>,
<val>t</val>, <val>e_content</val>, or <val>xml:id</val>, but not
<val>grand wazoo</val> or <val>1234</val>. Attributes of this kind are
typically used to represent XML element or attribute names.</p>

<p>Attributes of  type <ident type="datatype">data.enumerated</ident>,
such as <att>anchored</att> on  <gi>note</gi> have the same definition
as  <ident  type="datatype">data.word</ident>  above, with  the  added
semantics  that the word  supplied is  taken from  a specific  list of
possibilities. In each case,  the element or class specification which
includes the definition for the  attribute will also contain a list of
possible values,  together with a prose description  of their intended
significance.  This  list may  be  open (in  which  case  the list  is
advisory), or closed (in which  case, it determines the range of legal
values).</p>

<p>Attributes of type <ident type="datatype">data.code</ident> such as
<att>new</att> and <att>old</att> on <gi>handShift</gi> are similar in
function, in that they also  supply encoded names for values which are
defined  in more  detail elsewhere.  In this  case, however,  the full
definition is  supplied as content  of another XML  element, typically
but  not necessarily in  the same  document, and  it is  referenced by
means of a pointer. </p>

<specGrp xmlns:rng="http://relaxng.org/ns/structure/1.0" xml:id="DTYPES-4" n="Coded value datatypes">
&data.key;
&data.word;
&data.code;
&data.name;
&data.enumerated;
</specGrp>


<p>An attribute may, of course, take more than one value of a given type,
for example a list of pointer values, or a list of words. In the TEI
scheme, this information is regarded as property of the
<gi>datatype</gi> element used to document the attribute in question
rather than as a distinct <soCalled>datatype</soCalled>. See further
<ptr target="#TD-datatypes"/>. </p>
</div>

 </div>


<div type="div2" xml:id="STOV"><head>The TEI Infrastructure Module</head>

<p>The <ident type="class">tei</ident> module defined by this chapter
is a required component of any TEI schema. It provides declarations
for all datatypes, and for the attribute classes, model classes, and
macros used by other modules in the TEI scheme. Its components are
listed below in alphabetical order:

<moduleSpec xml:id="DSTTEI2" ident="tei" type="core">
<altIdent type="FPI">TEI Infrastructure</altIdent>
<desc>Declarations for datatypes, classes, and macros available to all
TEI modules</desc>
</moduleSpec>
</p>

<p>The order in which declarations are provided within the
infrastructure module is critical, since several class declarations
refer to others, which must therefore precede them. Other constraints
on the order of declarations derive from the way in which the
modularity of the TEI scheme is implemented in different schema
languages. The XML DTD fragment implementing this TEI module make
extensive use of <term>parameter entities</term> and <term>marked
sections</term> to effect a kind of conditional construction; the
RELAX NG schema fragment similarly predeclares a number of patterns
with null (<soCalled>notAllowed</soCalled>) values. These techniques
are further explained in chapter <ptr target="#IM"/>. </p>

<p>The RELAX NG schema fragment corresponding to this module  is
organized as follows:

<list>
<item>Declare default values for predeclared classes</item>
<item>Declare initial values for all classes</item>
<item>Declare all macros</item>
</list>
</p>


<p>The XML DTD module fragment corresponding to this chapter is organized as follows: 
<list>
<item>Declare naming entities for all elements to permit renaming (see
further <ptr target="#STPEGI"/>).</item>
<item>Embed any user-supplied entity declarations (see
further <ptr target="#STOVLO"/>).</item>
<item>Embed all available datatype macro declarations (see <ptr target="#DTYPES"/>)</item>
<!--<item>Declare TEI.XML marked section to permit SGML support (see
further <ptr target="#STXML"/>). </item>-->
<item>Embed all <soCalled>pre-declared</soCalled>  class and
macro declarations</item>
<item>Embed all other globally available class declarations </item>
<item>Embed conditionally available module-specific classes (see
further <ptr target="#STPED"/>). </item>
<item>Embed all other macro declarations</item>
<item>Embed any user-supplied element declarations (see
further <ptr target="#STOVLO"/>).  </item>
<item>Embed conditionally available module-specific declarations (see
further <ptr target="#STPED"/>).</item>
</list>
Note that some of these components are automatically
generated by the ODD processor. 
</p>

<!--<p>This simpler structure is a consequence of the way that the RELAX NG
schema language permits declarations to be combined from different
modules in any order, provided that the patterns defining those
declarations are properly initialised.</p>
-->
</div>


</div>
