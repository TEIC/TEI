namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace ns1 = "http://www.isocat.org/ns/dcr"
namespace rng = "http://relaxng.org/ns/structure/1.0"
namespace sch = "http://purl.oclc.org/dsdl/schematron"
namespace tei = "http://www.tei-c.org/ns/1.0"
default namespace teix = "http://www.tei-c.org/ns/Examples"

# Schema generated 2019-01-21T23:48:03Z
# Edition: Version 3.5.0a. Last updated on
#	19th January 2019, revision e6ccc03
# This material is dual-licensed.
# [http://creativecommons.org/licenses/by/3.0/] Distributed under a Creative Commons Attribution 3.0 Unported License.  [http://www.opensource.org/licenses/BSD-2-Clause] Copyright 2019 TEI Consortium. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. This software is provided by the copyright holders and contributors "as is" and any express or implied warranties, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose are disclaimed. In no event shall the copyright holder or contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage. TEI material can be licensed differently depending on the use you intend to make of it. Hence it is made available under both the CC+BY and BSD-2 licences. The CC+BY licence is generally appropriate for usages which treat TEI content as data or documentation. The BSD-2 licence is generally appropriate for usage of TEI content in a software environment. For further information or clarification, please contact the TEI Consortium. Declarations for classes, datatypes, and macros available to all TEI modules

# Definitions from module tei

# Set global predeclared macros
TEI |= notAllowed
ab |= notAllowed
abbr |= notAllowed
abstract |= notAllowed
accMat |= notAllowed
acquisition |= notAllowed
activity |= notAllowed
actor |= notAllowed
add |= notAllowed
addName |= notAllowed
addSpan |= notAllowed
additional |= notAllowed
additions |= notAllowed
addrLine |= notAllowed
address |= notAllowed
adminInfo |= notAllowed
affiliation |= notAllowed
age |= notAllowed
alt |= notAllowed
altGrp |= notAllowed
altIdent |= notAllowed
altIdentifier |= notAllowed
alternate |= notAllowed
am |= notAllowed
analytic |= notAllowed
anchor |= notAllowed
annotationBlock |= notAllowed
anyElement |= notAllowed
app |= notAllowed
appInfo |= notAllowed
application |= notAllowed
arc |= notAllowed
argument |= notAllowed
att |= notAllowed
attDef |= notAllowed
attList |= notAllowed
attRef |= notAllowed
author |= notAllowed
authority |= notAllowed
availability |= notAllowed
back |= notAllowed
bibl |= notAllowed
biblFull |= notAllowed
biblScope |= notAllowed
biblStruct |= notAllowed
bicond |= notAllowed
binary |= notAllowed
binaryObject |= notAllowed
binding |= notAllowed
bindingDesc |= notAllowed
birth |= notAllowed
bloc |= notAllowed
body |= notAllowed
broadcast |= notAllowed
byline |= notAllowed
c |= notAllowed
cRefPattern |= notAllowed
caesura |= notAllowed
calendar |= notAllowed
calendarDesc |= notAllowed
camera |= notAllowed
caption |= notAllowed
case |= notAllowed
castGroup |= notAllowed
castItem |= notAllowed
castList |= notAllowed
catDesc |= notAllowed
catRef |= notAllowed
catchwords |= notAllowed
category |= notAllowed
cb |= notAllowed
cell |= notAllowed
certainty |= notAllowed
change |= notAllowed
channel |= notAllowed
char |= notAllowed
charDecl |= notAllowed
charName |= notAllowed
charProp |= notAllowed
choice |= notAllowed
cit |= notAllowed
citedRange |= notAllowed
cl |= notAllowed
classCode |= notAllowed
classDecl |= notAllowed
classRef |= notAllowed
classSpec |= notAllowed
classes |= notAllowed
climate |= notAllowed
closer |= notAllowed
code |= notAllowed
collation |= notAllowed
collection |= notAllowed
colloc |= notAllowed
colophon |= notAllowed
cond |= notAllowed
condition |= notAllowed
constitution |= notAllowed
constraint |= notAllowed
constraintSpec |= notAllowed
content |= notAllowed
corr |= notAllowed
correction |= notAllowed
correspAction |= notAllowed
correspContext |= notAllowed
correspDesc |= notAllowed
country |= notAllowed
creation |= notAllowed
custEvent |= notAllowed
custodialHist |= notAllowed
damage |= notAllowed
damageSpan |= notAllowed
dataFacet |= notAllowed
dataRef |= notAllowed
dataSpec |= notAllowed
datatype |= notAllowed
date |= notAllowed
dateline |= notAllowed
death |= notAllowed
decoDesc |= notAllowed
decoNote |= notAllowed
def |= notAllowed
\default |= notAllowed
defaultVal |= notAllowed
del |= notAllowed
delSpan |= notAllowed
depth |= notAllowed
derivation |= notAllowed
desc |= notAllowed
dictScrap |= notAllowed
dim |= notAllowed
dimensions |= notAllowed
distinct |= notAllowed
distributor |= notAllowed
district |= notAllowed
\div |= notAllowed
div1 |= notAllowed
div2 |= notAllowed
div3 |= notAllowed
div4 |= notAllowed
div5 |= notAllowed
div6 |= notAllowed
div7 |= notAllowed
divGen |= notAllowed
docAuthor |= notAllowed
docDate |= notAllowed
docEdition |= notAllowed
docImprint |= notAllowed
docTitle |= notAllowed
domain |= notAllowed
eLeaf |= notAllowed
eTree |= notAllowed
edition |= notAllowed
editionStmt |= notAllowed
editor |= notAllowed
editorialDecl |= notAllowed
education |= notAllowed
eg |= notAllowed
egXML |= notAllowed
elementRef |= notAllowed
elementSpec |= notAllowed
email |= notAllowed
emph |= notAllowed
\empty |= notAllowed
encodingDesc |= notAllowed
entry |= notAllowed
entryFree |= notAllowed
epigraph |= notAllowed
epilogue |= notAllowed
equipment |= notAllowed
equiv |= notAllowed
etym |= notAllowed
event |= notAllowed
ex |= notAllowed
exemplum |= notAllowed
expan |= notAllowed
explicit |= notAllowed
extent |= notAllowed
f |= notAllowed
fDecl |= notAllowed
fDescr |= notAllowed
fLib |= notAllowed
facsimile |= notAllowed
factuality |= notAllowed
faith |= notAllowed
figDesc |= notAllowed
figure |= notAllowed
fileDesc |= notAllowed
filiation |= notAllowed
finalRubric |= notAllowed
floatingText |= notAllowed
floruit |= notAllowed
foliation |= notAllowed
foreign |= notAllowed
forename |= notAllowed
forest |= notAllowed
form |= notAllowed
formula |= notAllowed
front |= notAllowed
fs |= notAllowed
fsConstraints |= notAllowed
fsDecl |= notAllowed
fsDescr |= notAllowed
fsdDecl |= notAllowed
fsdLink |= notAllowed
funder |= notAllowed
fvLib |= notAllowed
fw |= notAllowed
g |= notAllowed
gap |= notAllowed
gb |= notAllowed
gen |= notAllowed
genName |= notAllowed
geo |= notAllowed
geoDecl |= notAllowed
geogFeat |= notAllowed
geogName |= notAllowed
gi |= notAllowed
gloss |= notAllowed
glyph |= notAllowed
glyphName |= notAllowed
gram |= notAllowed
gramGrp |= notAllowed
graph |= notAllowed
graphic |= notAllowed
group |= notAllowed
handDesc |= notAllowed
handNote |= notAllowed
handNotes |= notAllowed
handShift |= notAllowed
head |= notAllowed
headItem |= notAllowed
headLabel |= notAllowed
height |= notAllowed
heraldry |= notAllowed
hi |= notAllowed
history |= notAllowed
hom |= notAllowed
hyph |= notAllowed
hyphenation |= notAllowed
iNode |= notAllowed
iType |= notAllowed
ident |= notAllowed
idno |= notAllowed
if |= notAllowed
iff |= notAllowed
imprimatur |= notAllowed
imprint |= notAllowed
incident |= notAllowed
incipit |= notAllowed
index |= notAllowed
institution |= notAllowed
interaction |= notAllowed
interp |= notAllowed
interpGrp |= notAllowed
interpretation |= notAllowed
item |= notAllowed
join |= notAllowed
joinGrp |= notAllowed
keywords |= notAllowed
kinesic |= notAllowed
l |= notAllowed
label |= notAllowed
lacunaEnd |= notAllowed
lacunaStart |= notAllowed
lang |= notAllowed
langKnowledge |= notAllowed
langKnown |= notAllowed
langUsage |= notAllowed
language |= notAllowed
layout |= notAllowed
layoutDesc |= notAllowed
lb |= notAllowed
lbl |= notAllowed
leaf |= notAllowed
lem |= notAllowed
lg |= notAllowed
licence |= notAllowed
line |= notAllowed
link |= notAllowed
linkGrp |= notAllowed
\list |= notAllowed
listApp |= notAllowed
listBibl |= notAllowed
listChange |= notAllowed
listEvent |= notAllowed
listForest |= notAllowed
listNym |= notAllowed
listObject |= notAllowed
listOrg |= notAllowed
listPerson |= notAllowed
listPlace |= notAllowed
listPrefixDef |= notAllowed
listRef |= notAllowed
listRelation |= notAllowed
listTranspose |= notAllowed
listWit |= notAllowed
localName |= notAllowed
locale |= notAllowed
location |= notAllowed
locus |= notAllowed
locusGrp |= notAllowed
m |= notAllowed
macroRef |= notAllowed
macroSpec |= notAllowed
mapping |= notAllowed
material |= notAllowed
measure |= notAllowed
measureGrp |= notAllowed
media |= notAllowed
meeting |= notAllowed
memberOf |= notAllowed
mentioned |= notAllowed
metDecl |= notAllowed
metSym |= notAllowed
metamark |= notAllowed
milestone |= notAllowed
mod |= notAllowed
model |= notAllowed
modelGrp |= notAllowed
modelSequence |= notAllowed
moduleRef |= notAllowed
moduleSpec |= notAllowed
monogr |= notAllowed
mood |= notAllowed
move |= notAllowed
msContents |= notAllowed
msDesc |= notAllowed
msFrag |= notAllowed
msIdentifier |= notAllowed
msItem |= notAllowed
msItemStruct |= notAllowed
msName |= notAllowed
msPart |= notAllowed
musicNotation |= notAllowed
name |= notAllowed
nameLink |= notAllowed
\namespace |= notAllowed
nationality |= notAllowed
node |= notAllowed
normalization |= notAllowed
notatedMusic |= notAllowed
note |= notAllowed
notesStmt |= notAllowed
num |= notAllowed
number |= notAllowed
numeric |= notAllowed
nym |= notAllowed
oRef |= notAllowed
object |= notAllowed
objectDesc |= notAllowed
objectIdentifier |= notAllowed
objectName |= notAllowed
objectType |= notAllowed
occupation |= notAllowed
offset |= notAllowed
opener |= notAllowed
org |= notAllowed
orgName |= notAllowed
orig |= notAllowed
origDate |= notAllowed
origPlace |= notAllowed
origin |= notAllowed
orth |= notAllowed
outputRendition |= notAllowed
p |= notAllowed
pRef |= notAllowed
param |= notAllowed
paramList |= notAllowed
paramSpec |= notAllowed
particDesc |= notAllowed
path |= notAllowed
pause |= notAllowed
pb |= notAllowed
pc |= notAllowed
per |= notAllowed
performance |= notAllowed
persName |= notAllowed
person |= notAllowed
personGrp |= notAllowed
persona |= notAllowed
phr |= notAllowed
physDesc |= notAllowed
place |= notAllowed
placeName |= notAllowed
population |= notAllowed
pos |= notAllowed
postBox |= notAllowed
postCode |= notAllowed
postscript |= notAllowed
precision |= notAllowed
prefixDef |= notAllowed
preparedness |= notAllowed
principal |= notAllowed
profileDesc |= notAllowed
projectDesc |= notAllowed
prologue |= notAllowed
pron |= notAllowed
provenance |= notAllowed
ptr |= notAllowed
pubPlace |= notAllowed
publicationStmt |= notAllowed
publisher |= notAllowed
punctuation |= notAllowed
purpose |= notAllowed
q |= notAllowed
quotation |= notAllowed
quote |= notAllowed
rdg |= notAllowed
rdgGrp |= notAllowed
re |= notAllowed
recordHist |= notAllowed
recording |= notAllowed
recordingStmt |= notAllowed
redo |= notAllowed
ref |= notAllowed
refState |= notAllowed
refsDecl |= notAllowed
reg |= notAllowed
region |= notAllowed
relatedItem |= notAllowed
relation |= notAllowed
remarks |= notAllowed
rendition |= notAllowed
repository |= notAllowed
residence |= notAllowed
resp |= notAllowed
respStmt |= notAllowed
respons |= notAllowed
restore |= notAllowed
retrace |= notAllowed
revisionDesc |= notAllowed
rhyme |= notAllowed
role |= notAllowed
roleDesc |= notAllowed
roleName |= notAllowed
root |= notAllowed
row |= notAllowed
rs |= notAllowed
rubric |= notAllowed
s |= notAllowed
said |= notAllowed
salute |= notAllowed
samplingDecl |= notAllowed
schemaRef |= notAllowed
schemaSpec |= notAllowed
scriptDesc |= notAllowed
scriptNote |= notAllowed
scriptStmt |= notAllowed
seal |= notAllowed
sealDesc |= notAllowed
secFol |= notAllowed
secl |= notAllowed
seg |= notAllowed
segmentation |= notAllowed
sense |= notAllowed
sequence |= notAllowed
series |= notAllowed
seriesStmt |= notAllowed
set |= notAllowed
setting |= notAllowed
settingDesc |= notAllowed
settlement |= notAllowed
sex |= notAllowed
shift |= notAllowed
sic |= notAllowed
signatures |= notAllowed
signed |= notAllowed
soCalled |= notAllowed
socecStatus |= notAllowed
sound |= notAllowed
source |= notAllowed
sourceDesc |= notAllowed
sourceDoc |= notAllowed
sp |= notAllowed
spGrp |= notAllowed
space |= notAllowed
span |= notAllowed
spanGrp |= notAllowed
speaker |= notAllowed
specDesc |= notAllowed
specGrp |= notAllowed
specGrpRef |= notAllowed
specList |= notAllowed
sponsor |= notAllowed
stage |= notAllowed
stamp |= notAllowed
state |= notAllowed
stdVals |= notAllowed
street |= notAllowed
stress |= notAllowed
\string |= notAllowed
styleDefDecl |= notAllowed
subc |= notAllowed
subst |= notAllowed
substJoin |= notAllowed
summary |= notAllowed
superEntry |= notAllowed
supplied |= notAllowed
support |= notAllowed
supportDesc |= notAllowed
surface |= notAllowed
surfaceGrp |= notAllowed
surname |= notAllowed
surplus |= notAllowed
surrogates |= notAllowed
syll |= notAllowed
symbol |= notAllowed
table |= notAllowed
tag |= notAllowed
tagUsage |= notAllowed
tagsDecl |= notAllowed
taxonomy |= notAllowed
tech |= notAllowed
teiCorpus |= notAllowed
teiHeader |= notAllowed
term |= notAllowed
terrain |= notAllowed
\text |= notAllowed
textClass |= notAllowed
textDesc |= notAllowed
textLang |= notAllowed
textNode |= notAllowed
then |= notAllowed
time |= notAllowed
timeline |= notAllowed
title |= notAllowed
titlePage |= notAllowed
titlePart |= notAllowed
titleStmt |= notAllowed
tns |= notAllowed
trailer |= notAllowed
trait |= notAllowed
transcriptionDesc |= notAllowed
transpose |= notAllowed
tree |= notAllowed
triangle |= notAllowed
typeDesc |= notAllowed
typeNote |= notAllowed
u |= notAllowed
unclear |= notAllowed
undo |= notAllowed
unicodeName |= notAllowed
unit |= notAllowed
usg |= notAllowed
vAlt |= notAllowed
vColl |= notAllowed
vDefault |= notAllowed
vLabel |= notAllowed
vMerge |= notAllowed
vNot |= notAllowed
vRange |= notAllowed
val |= notAllowed
valDesc |= notAllowed
valItem |= notAllowed
valList |= notAllowed
value |= notAllowed
variantEncoding |= notAllowed
view |= notAllowed
vocal |= notAllowed
w |= notAllowed
watermark |= notAllowed
when |= notAllowed
width |= notAllowed
wit |= notAllowed
witDetail |= notAllowed
witEnd |= notAllowed
witStart |= notAllowed
witness |= notAllowed
writing |= notAllowed
xenoData |= notAllowed
xr |= notAllowed
zone |= notAllowed
# Set predeclared macros

# 0. predeclared classes
att.datable.custom.attributes |= empty
att.duration.w3c.attributes |= empty
att.duration.attributes |= empty
att.global.responsibility.attributes |= empty
att.global.rendition.attributes |= empty
att.global.source.attributes |= empty
model.entryPart |= notAllowed
model.entryPart_alternation |= notAllowed
model.entryPart_sequence |= notAllowed
model.entryPart_sequenceOptional |= notAllowed
model.entryPart_sequenceOptionalRepeatable |= notAllowed
model.entryPart_sequenceRepeatable |= notAllowed
model.eventLike |= notAllowed
model.eventLike_alternation |= notAllowed
model.eventLike_sequence |= notAllowed
model.eventLike_sequenceOptional |= notAllowed
model.eventLike_sequenceOptionalRepeatable |= notAllowed
model.eventLike_sequenceRepeatable |= notAllowed
model.global.spoken |= notAllowed
model.global.spoken_alternation |= notAllowed
model.global.spoken_sequence |= notAllowed
model.global.spoken_sequenceOptional |= notAllowed
model.global.spoken_sequenceOptionalRepeatable |= notAllowed
model.global.spoken_sequenceRepeatable |= notAllowed
model.placeNamePart |= notAllowed
model.placeNamePart_alternation |= notAllowed
model.placeNamePart_sequence |= notAllowed
model.placeNamePart_sequenceOptional |= notAllowed
model.placeNamePart_sequenceOptionalRepeatable |= notAllowed
model.placeNamePart_sequenceRepeatable |= notAllowed
model.placeStateLike |= notAllowed
model.placeStateLike_alternation |= notAllowed
model.placeStateLike_sequence |= notAllowed
model.placeStateLike_sequenceOptional |= notAllowed
model.placeStateLike_sequenceOptionalRepeatable |= notAllowed
model.placeStateLike_sequenceRepeatable |= notAllowed
model.orgPart |= notAllowed
model.orgPart_alternation |= notAllowed
model.orgPart_sequence |= notAllowed
model.orgPart_sequenceOptional |= notAllowed
model.orgPart_sequenceOptionalRepeatable |= notAllowed
model.orgPart_sequenceRepeatable |= notAllowed
model.persNamePart |= notAllowed
model.persNamePart_alternation |= notAllowed
model.persNamePart_sequence |= notAllowed
model.persNamePart_sequenceOptional |= notAllowed
model.persNamePart_sequenceOptionalRepeatable |= notAllowed
model.persNamePart_sequenceRepeatable |= notAllowed
att.metrical.attributes |= empty
att.enjamb.attributes |= empty
model.divPart.spoken |= notAllowed
model.divPart.spoken_alternation |= notAllowed
model.divPart.spoken_sequence |= notAllowed
model.divPart.spoken_sequenceOptional |= notAllowed
model.divPart.spoken_sequenceOptionalRepeatable |= notAllowed
model.divPart.spoken_sequenceRepeatable |= notAllowed
model.entryLike |= notAllowed
model.entryLike_alternation |= notAllowed
model.entryLike_sequence |= notAllowed
model.entryLike_sequenceOptional |= notAllowed
model.entryLike_sequenceOptionalRepeatable |= notAllowed
model.entryLike_sequenceRepeatable |= notAllowed
model.ptrLike.form |= notAllowed
model.ptrLike.form_alternation |= notAllowed
model.ptrLike.form_sequence |= notAllowed
model.ptrLike.form_sequenceOptional |= notAllowed
model.ptrLike.form_sequenceOptionalRepeatable |= notAllowed
model.ptrLike.form_sequenceRepeatable |= notAllowed
att.msExcerpt.attributes |= empty
att.global.facs.attributes |= empty
att.global.change.attributes |= empty
model.resourceLike |= notAllowed
model.resourceLike_alternation |= notAllowed
model.resourceLike_sequence |= notAllowed
model.resourceLike_sequenceOptional |= notAllowed
model.resourceLike_sequenceOptionalRepeatable |= notAllowed
model.resourceLike_sequenceRepeatable |= notAllowed
model.objectLike |= notAllowed
model.objectLike_alternation |= notAllowed
model.objectLike_sequence |= notAllowed
model.objectLike_sequenceOptional |= notAllowed
model.objectLike_sequenceOptionalRepeatable |= notAllowed
model.objectLike_sequenceRepeatable |= notAllowed
model.orgStateLike |= notAllowed
model.orgStateLike_alternation |= notAllowed
model.orgStateLike_sequence |= notAllowed
model.orgStateLike_sequenceOptional |= notAllowed
model.orgStateLike_sequenceOptionalRepeatable |= notAllowed
model.orgStateLike_sequenceRepeatable |= notAllowed
att.datable.iso.attributes |= empty
att.duration.iso.attributes |= empty
att.global.linking.attributes |= empty
att.global.analytic.attributes |= empty
att.deprecated.attributes |= empty
anyElement-xenoData =
  element * - (tei:* | egXML) {
    attribute * { text }*,
    (text | anyElement-xenoData)*
  }
anyElement-egXML =
  element * - (tei:* | egXML) {
    attribute * { text }*,
    (text | anyElement-egXML)*
  }
anyElement-content =
  element * - (tei:* | egXML) {
    attribute * { text }*,
    (text | anyElement-content)*
  }
  >> sch:pattern [
       id = "d8e120046-constraint"
       "\x{a}" ~
       "         "
       sch:rule [
         context = "tei:content"
         "\x{a}" ~
         "            "
         sch:report [
           test =
             "descendant::*[not(namespace-uri(.) =               ('http://relaxng.org/ns/structure/1.0', 'http://www.tei-c.org/ns/1.0'))]"
           "content descendants must be in the\x{a}" ~
           "              namespaces\x{a}" ~
           "              'http://relaxng.org/ns/structure/1.0', 'http://www.tei-c.org/ns/1.0'"
         ]
         "\x{a}" ~
         "         "
       ]
       "\x{a}" ~
       "      "
     ]
anyElement-constraint =
  element * - (tei:* | egXML) {
    attribute * { text }*,
    (text | anyElement-constraint)*
  }
anyElement-datatype =
  element * - (tei:* | egXML) {
    attribute * { text }*,
    (text | anyElement-datatype)*
  }
  >> sch:pattern [
       id = "d8e121459-constraint"
       "\x{a}" ~
       "         "
       sch:rule [
         context = "tei:datatype"
         "\x{a}" ~
         "            "
         sch:report [
           test =
             "descendant::*[not(namespace-uri(.) =               ('http://relaxng.org/ns/structure/1.0', 'http://www.tei-c.org/ns/1.0'))]"
           "datatype descendants must be in the\x{a}" ~
           "              namespaces\x{a}" ~
           "              'http://relaxng.org/ns/structure/1.0', 'http://www.tei-c.org/ns/1.0'"
         ]
         "\x{a}" ~
         "         "
       ]
       "\x{a}" ~
       "      "
     ]
# 0. predeclared macros

# 1. classes
att.ascribed.attributes = att.ascribed.attribute.who
att.ascribed.attribute.who =
  
  ## indicates the person, or group of people, to whom the element content is ascribed.
  attribute who {
    list { xsd:anyURI+ }
  }?
att.ascribed.directed.attributes =
  att.ascribed.attributes, att.ascribed.directed.attribute.toWhom
att.ascribed.directed.attribute.toWhom =
  
  ## indicates the person, or group of people, to whom a speech act or action is directed.
  attribute toWhom {
    list { xsd:anyURI+ }
  }?
att.canonical.attributes =
  att.canonical.attribute.key, att.canonical.attribute.ref
att.canonical.attribute.key =
  
  ## provides an externally-defined means of identifying the entity (or entities) being named, using a coded value of some kind.
  attribute key { xsd:string }?
att.canonical.attribute.ref =
  
  ## (reference) provides an explicit means of locating a full definition or identity for the entity being named by means of one or more URIs.
  attribute ref {
    list { xsd:anyURI+ }
  }?
att.ranging.attributes =
  att.ranging.attribute.atLeast,
  att.ranging.attribute.atMost,
  att.ranging.attribute.min,
  att.ranging.attribute.max,
  att.ranging.attribute.confidence
att.ranging.attribute.atLeast =
  
  ## gives a minimum estimated value for the approximate measurement.
  attribute atLeast {
    xsd:double
    | xsd:token { pattern = "(\-?[\d]+/\-?[\d]+)" }
    | xsd:decimal
  }?
att.ranging.attribute.atMost =
  
  ## gives a maximum estimated value for the approximate measurement.
  attribute atMost {
    xsd:double
    | xsd:token { pattern = "(\-?[\d]+/\-?[\d]+)" }
    | xsd:decimal
  }?
att.ranging.attribute.min =
  
  ## where the measurement summarizes more than one observation or a range, supplies the minimum value observed.
  attribute min {
    xsd:double
    | xsd:token { pattern = "(\-?[\d]+/\-?[\d]+)" }
    | xsd:decimal
  }?
att.ranging.attribute.max =
  
  ## where the measurement summarizes more than one observation or a range, supplies the maximum value observed.
  attribute max {
    xsd:double
    | xsd:token { pattern = "(\-?[\d]+/\-?[\d]+)" }
    | xsd:decimal
  }?
att.ranging.attribute.confidence =
  
  ## specifies the degree of statistical confidence (between zero and one) that a value falls within the range specified by min and max, or the proportion of observed values that fall within that range.
  attribute confidence { xsd:double }?
att.dimensions.attributes =
  att.ranging.attributes,
  att.dimensions.attribute.unit,
  att.dimensions.attribute.quantity,
  att.dimensions.attribute.extent,
  att.dimensions.attribute.precision,
  att.dimensions.attribute.scope
att.dimensions.attribute.unit =
  
  ## names the unit used for the measurement
  ## Suggested values include: 1] cm (centimetres) ; 2] mm (millimetres) ; 3] in (inches) ; 4] lines; 5] chars (characters) 
  attribute unit {
    
    ## (centimetres) 
    "cm"
    | 
      ## (millimetres) 
      "mm"
    | 
      ## (inches) 
      "in"
    | 
      ## lines of text
      "lines"
    | 
      ## (characters) characters of text
      "chars"
    | xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
  }?
att.dimensions.attribute.quantity =
  
  ## specifies the length in the units specified
  attribute quantity {
    xsd:double
    | xsd:token { pattern = "(\-?[\d]+/\-?[\d]+)" }
    | xsd:decimal
  }?
att.dimensions.attribute.extent =
  
  ## indicates the size of the object concerned using a project-specific vocabulary combining quantity and units in a single string of words.
  attribute extent { xsd:string }?
att.dimensions.attribute.precision =
  
  ## characterizes the precision of the values specified by the other attributes.
  attribute precision {
    
    ##
    "high"
    | 
      ##
      "medium"
    | 
      ##
      "low"
    | 
      ##
      "unknown"
  }?
att.dimensions.attribute.scope =
  
  ## where the measurement summarizes more than one observation, specifies the applicability of this measurement.
  ## Sample values include: 1] all; 2] most; 3] range
  attribute scope {
    xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
  }?
att.written.attributes = att.written.attribute.hand
att.written.attribute.hand =
  
  ## points to a handNote element describing the hand considered responsible for the content of the element concerned.
  attribute hand { xsd:anyURI }?
att.damaged.attributes =
  att.dimensions.attributes,
  att.written.attributes,
  att.damaged.attribute.agent,
  att.damaged.attribute.degree,
  att.damaged.attribute.group
att.damaged.attribute.agent =
  
  ## categorizes the cause of the damage, if it can be identified.
  ## Sample values include: 1] rubbing; 2] mildew; 3] smoke
  attribute agent {
    xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
  }?
att.damaged.attribute.degree =
  
  ## provides a coded representation of the degree of damage, either as a number between 0 (undamaged) and 1 (very extensively damaged), or as one of the codes high, medium, low, or unknown. The damage element with the degree attribute should only be used where the text may be read with some confidence; text supplied from other sources should be tagged as supplied.
  attribute degree {
    xsd:double
    | (
       ##
       "high"
       | 
         ##
         "medium"
       | 
         ##
         "low"
       | 
         ##
         "unknown")
  }?
att.damaged.attribute.group =
  
  ## assigns an arbitrary number to each stretch of damage regarded as forming part of the same physical phenomenon.
  attribute group { xsd:nonNegativeInteger }?
att.breaking.attributes = att.breaking.attribute.break
att.breaking.attribute.break =
  
  ## indicates whether or not the element bearing this attribute should be considered to mark the end of an orthographic token in the same way as whitespace.
  attribute break {
    xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
  }?
att.cReferencing.attributes = att.cReferencing.attribute.cRef
att.cReferencing.attribute.cRef =
  
  ## (canonical reference) specifies the destination of the pointer by supplying a canonical reference expressed using the scheme defined in a refsDecl element in the TEI header
  attribute cRef { xsd:string }?
att.datable.w3c.attributes =
  att.datable.w3c.attribute.when,
  att.datable.w3c.attribute.notBefore,
  att.datable.w3c.attribute.notAfter,
  att.datable.w3c.attribute.from,
  att.datable.w3c.attribute.to
att.datable.w3c.attribute.when =
  
  ## supplies the value of the date or time in a standard form, e.g. yyyy-mm-dd.
  attribute when {
    xsd:date
    | xsd:gYear
    | xsd:gMonth
    | xsd:gDay
    | xsd:gYearMonth
    | xsd:gMonthDay
    | xsd:time
    | xsd:dateTime
  }?
att.datable.w3c.attribute.notBefore =
  
  ## specifies the earliest possible date for the event in standard form, e.g. yyyy-mm-dd.
  attribute notBefore {
    xsd:date
    | xsd:gYear
    | xsd:gMonth
    | xsd:gDay
    | xsd:gYearMonth
    | xsd:gMonthDay
    | xsd:time
    | xsd:dateTime
  }?
att.datable.w3c.attribute.notAfter =
  
  ## specifies the latest possible date for the event in standard form, e.g. yyyy-mm-dd.
  attribute notAfter {
    xsd:date
    | xsd:gYear
    | xsd:gMonth
    | xsd:gDay
    | xsd:gYearMonth
    | xsd:gMonthDay
    | xsd:time
    | xsd:dateTime
  }?
att.datable.w3c.attribute.from =
  
  ## indicates the starting point of the period in standard form, e.g. yyyy-mm-dd.
  attribute from {
    xsd:date
    | xsd:gYear
    | xsd:gMonth
    | xsd:gDay
    | xsd:gYearMonth
    | xsd:gMonthDay
    | xsd:time
    | xsd:dateTime
  }?
att.datable.w3c.attribute.to =
  
  ## indicates the ending point of the period in standard form, e.g. yyyy-mm-dd.
  attribute to {
    xsd:date
    | xsd:gYear
    | xsd:gMonth
    | xsd:gDay
    | xsd:gYearMonth
    | xsd:gMonthDay
    | xsd:time
    | xsd:dateTime
  }?
sch:pattern [
  id = "att.datable.w3c-att-datable-w3c-when-constraint-rule-1"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "tei:*[@when]"
    "\x{a}" ~
    "        "
    sch:report [
      test = "@notBefore|@notAfter|@from|@to"
      role = "nonfatal"
      "The @when attribute cannot be used with any other att.datable.w3c attributes."
    ]
    "\x{a}" ~
    "      "
  ]
  "\x{a}" ~
  "   "
]
sch:pattern [
  id = "att.datable.w3c-att-datable-w3c-from-constraint-rule-2"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "tei:*[@from]"
    "\x{a}" ~
    "        "
    sch:report [
      test = "@notBefore"
      role = "nonfatal"
      "The @from and @notBefore attributes cannot be used together."
    ]
    "\x{a}" ~
    "      "
  ]
  "\x{a}" ~
  "   "
]
sch:pattern [
  id = "att.datable.w3c-att-datable-w3c-to-constraint-rule-3"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "tei:*[@to]"
    "\x{a}" ~
    "        "
    sch:report [
      test = "@notAfter"
      role = "nonfatal"
      "The @to and @notAfter attributes cannot be used together."
    ]
    "\x{a}" ~
    "      "
  ]
  "\x{a}" ~
  "   "
]
att.datable.attributes =
  att.datable.w3c.attributes,
  att.datable.iso.attributes,
  att.datable.custom.attributes,
  att.datable.attribute.calendar,
  att.datable.attribute.period
att.datable.attribute.calendar =
  
  ## indicates the system or calendar to which the date represented by the content of this element belongs.
  attribute calendar { xsd:anyURI }?
sch:pattern [
  id = "att.datable-calendar-calendar-constraint-rule-4"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "tei:*[@calendar]"
    "\x{a}" ~
    "            "
    sch:assert [
      test = "string-length(.) gt 0"
      "\x{a}" ~
      "@calendar indicates the system or calendar to which the date represented by the content of this element\x{a}" ~
      "belongs, but this "
      sch:name [ ]
      " element has no textual content."
    ]
    "\x{a}" ~
    "          "
  ]
  "\x{a}" ~
  "   "
]
att.datable.attribute.period =
  
  ## supplies a pointer to some location defining a named period of time within which the datable item is understood to have occurred.
  attribute period { xsd:anyURI }?
att.datcat.attributes =
  att.datcat.attribute.datcat, att.datcat.attribute.valueDatcat
att.datcat.attribute.datcat =
  
  ## contains a PID (persistent identifier) that aligns the given element with the appropriate Data Category (or categories) in ISOcat.
  attribute ns1:datcat {
    list { xsd:anyURI+ }
  }?
att.datcat.attribute.valueDatcat =
  
  ## contains a PID (persistent identifier) that aligns the content of the given element or the value of the given attribute with the appropriate simple Data Category (or categories) in ISOcat.
  attribute ns1:valueDatcat {
    list { xsd:anyURI+ }
  }?
att.declarable.attributes = att.declarable.attribute.default
att.declarable.attribute.default =
  
  ## indicates whether or not this element is selected by default when its parent is selected.
  [ a:defaultValue = "false" ]
  attribute default {
    
    ## This element is selected if its parent is selected
    "true"
    | 
      ## This element can only be selected explicitly, unless it is the only one of its kind, in which case it is selected if its parent is selected.
      "false"
  }?
att.declaring.attributes = att.declaring.attribute.decls
att.declaring.attribute.decls =
  
  ## identifies one or more declarable elements within the header, which are understood to apply to the element bearing this attribute and its content.
  attribute decls {
    list { xsd:anyURI+ }
  }?
att.fragmentable.attributes = att.fragmentable.attribute.part
att.fragmentable.attribute.part =
  
  ## specifies whether or not its parent element is fragmented in some way, typically by some other overlapping structure: for example a speech which is divided between two or more verse stanzas, a paragraph which is split across a page division, a verse line which is divided between two speakers.
  [ a:defaultValue = "N" ]
  attribute part {
    
    ## (yes) the element is fragmented in some (unspecified) respect
    "Y"
    | 
      ## (no) the element is not fragmented, or no claim is made as to its completeness
      "N"
    | 
      ## (initial) this is the initial part of a fragmented element
      "I"
    | 
      ## (medial) this is a medial part of a fragmented element
      "M"
    | 
      ## (final) this is the final part of a fragmented element
      "F"
  }?
att.divLike.attributes =
  att.metrical.attributes,
  att.fragmentable.attributes,
  att.divLike.attribute.org,
  att.divLike.attribute.sample
att.divLike.attribute.org =
  
  ## (organization) specifies how the content of the division is organized.
  [ a:defaultValue = "uniform" ]
  attribute org {
    
    ## no claim is made about the sequence in which the immediate contents of this division are to be processed, or their inter-relationships.
    "composite"
    | 
      ## the immediate contents of this element are regarded as forming a logical unit, to be processed in sequence.
      "uniform"
  }?
att.divLike.attribute.sample =
  
  ## indicates whether this division is a sample of the original source and if so, from which part.
  [ a:defaultValue = "complete" ]
  attribute sample {
    
    ## division lacks material present at end in source.
    "initial"
    | 
      ## division lacks material at start and end.
      "medial"
    | 
      ## division lacks material at start.
      "final"
    | 
      ## position of sampled material within original unknown.
      "unknown"
    | 
      ## division is not a sample.
      "complete"
  }?
att.docStatus.attributes = att.docStatus.attribute.status
att.docStatus.attribute.status =
  
  ## describes the status of a document either currently or, when associated with a dated element, at the time indicated.
  ## Sample values include: 1] approved; 2] candidate; 3] cleared; 4] deprecated; 5] draft; 6] embargoed; 7] expired; 8] frozen; 9] galley; 10] proposed; 11] published; 12] recommendation; 13] submitted; 14] unfinished; 15] withdrawn
  [ a:defaultValue = "draft" ]
  attribute status {
    xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
  }?
att.duration.w3c.attributes = att.duration.w3c.attribute.dur
att.duration.w3c.attribute.dur =
  
  ## (duration) indicates the length of this element in time.
  attribute dur { xsd:duration }?
att.global.responsibility.attributes =
  att.global.responsibility.attribute.cert,
  att.global.responsibility.attribute.resp
att.global.responsibility.attribute.cert =
  
  ## (certainty) signifies the degree of certainty associated with the intervention or interpretation.
  attribute cert {
    xsd:double
    | (
       ##
       "high"
       | 
         ##
         "medium"
       | 
         ##
         "low"
       | 
         ##
         "unknown")
  }?
att.global.responsibility.attribute.resp =
  
  ## (responsible party) indicates the agency responsible for the intervention or interpretation, for example an editor or transcriber.
  attribute resp {
    list { xsd:anyURI+ }
  }?
att.editLike.attributes =
  att.editLike.attribute.evidence, att.editLike.attribute.instant
att.editLike.attribute.evidence =
  
  ## indicates the nature of the evidence supporting the reliability or accuracy of the intervention or interpretation.
  ## Suggested values include: 1] internal; 2] external; 3] conjecture
  attribute evidence {
    list {
      (
       ## there is internal evidence to support the intervention.
       "internal"
       | 
         ## there is external evidence to support the intervention.
         "external"
       | 
         ## the intervention or interpretation has been made by the editor, cataloguer, or scholar on the basis of their expertise.
         "conjecture"
       | xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" })+
    }
  }?
att.editLike.attribute.instant =
  
  ## indicates whether this is an instant revision or not.
  [ a:defaultValue = "false" ]
  attribute instant {
    xsd:boolean
    | (
       ##
       "unknown"
       | 
         ##
         "inapplicable")
  }?
att.global.rendition.attributes =
  att.global.rendition.attribute.rend,
  att.global.rendition.attribute.style,
  att.global.rendition.attribute.rendition
att.global.rendition.attribute.rend =
  
  ## (rendition) indicates how the element in question was rendered or presented in the source text.
  attribute rend {
    list {
      xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }+
    }
  }?
att.global.rendition.attribute.style =
  
  ## contains an expression in some formal style definition language which defines the rendering or presentation used for this element in the source text
  attribute style { xsd:string }?
att.global.rendition.attribute.rendition =
  
  ## points to a description of the rendering or presentation used for this element in the source text.
  attribute rendition {
    list { xsd:anyURI+ }
  }?
att.global.source.attributes = att.global.source.attribute.source
att.global.source.attribute.source =
  
  ## specifies the source from which some aspect of this element is drawn.
  attribute source {
    list { xsd:anyURI+ }
  }?
att.global.attributes =
  att.global.rendition.attributes,
  att.global.linking.attributes,
  att.global.analytic.attributes,
  att.global.facs.attributes,
  att.global.change.attributes,
  att.global.responsibility.attributes,
  att.global.source.attributes,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.xmlbase,
  att.global.attribute.xmlspace
att.global.attribute.xmlid =
  
  ## (identifier) provides a unique identifier for the element bearing the attribute.
  attribute xml:id { xsd:ID }?
att.global.attribute.n =
  
  ## (number) gives a number (or other label) for an element, which is not necessarily unique within the document.
  attribute n { xsd:string }?
att.global.attribute.xmllang =
  
  ## (language) indicates the language of the element content using a tag generated according to BCP 47.
  attribute xml:lang {
    xsd:language
    | (
       ##
       "")
  }?
att.global.attribute.xmlbase =
  
  ## provides a base URI reference with which applications can resolve relative URI references into absolute URI references.
  attribute xml:base { xsd:anyURI }?
att.global.attribute.xmlspace =
  
  ## signals an intention about how white space should be managed by applications.
  attribute xml:space {
    
    ## signals that the application's default white-space processing modes are acceptable
    "default"
    | 
      ## indicates the intent that applications preserve all white space
      "preserve"
  }?
att.handFeatures.attributes =
  att.handFeatures.attribute.scribe,
  att.handFeatures.attribute.scribeRef,
  att.handFeatures.attribute.script,
  att.handFeatures.attribute.scriptRef,
  att.handFeatures.attribute.medium,
  att.handFeatures.attribute.scope
att.handFeatures.attribute.scribe =
  
  ## gives a name or other identifier for the scribe believed to be responsible for this hand.
  attribute scribe { xsd:Name }?
att.handFeatures.attribute.scribeRef =
  
  ## points to a full description of the scribe concerned, typically supplied by a person element elsewhere in the description.
  attribute scribeRef {
    list { xsd:anyURI+ }
  }?
att.handFeatures.attribute.script =
  
  ## characterizes the particular script or writing style used by this hand, for example secretary, copperplate, Chancery, Italian, etc.
  attribute script {
    list { xsd:Name+ }
  }?
att.handFeatures.attribute.scriptRef =
  
  ## points to a full description of the script or writing style used by this hand, typically supplied by a scriptNote element elsewhere in the description.
  attribute scriptRef {
    list { xsd:anyURI+ }
  }?
att.handFeatures.attribute.medium =
  
  ## describes the tint or type of ink, e.g. brown, or other writing medium, e.g. pencil
  attribute medium {
    list {
      xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }+
    }
  }?
att.handFeatures.attribute.scope =
  
  ## specifies how widely this hand is used in the manuscript.
  attribute scope {
    
    ## only this hand is used throughout the manuscript
    "sole"
    | 
      ## this hand is used through most of the manuscript
      "major"
    | 
      ## this hand is used occasionally in the manuscript
      "minor"
  }?
att.internetMedia.attributes = att.internetMedia.attribute.mimeType
att.internetMedia.attribute.mimeType =
  
  ## (MIME media type) specifies the applicable multimedia internet mail extension (MIME) media type
  attribute mimeType {
    list {
      xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }+
    }
  }?
att.media.attributes =
  att.internetMedia.attributes,
  att.media.attribute.width,
  att.media.attribute.height,
  att.media.attribute.scale
att.media.attribute.width =
  
  ## Where the media are displayed, indicates the display width
  attribute width {
    xsd:token {
      pattern =
        "[\-+]?\d+(\.\d+)?(%|cm|mm|in|pt|pc|px|em|ex|gd|rem|vw|vh|vm)"
    }
  }?
att.media.attribute.height =
  
  ## Where the media are displayed, indicates the display height
  attribute height {
    xsd:token {
      pattern =
        "[\-+]?\d+(\.\d+)?(%|cm|mm|in|pt|pc|px|em|ex|gd|rem|vw|vh|vm)"
    }
  }?
att.media.attribute.scale =
  
  ## Where the media are displayed, indicates a scale factor to be applied when generating the desired display size
  attribute scale {
    xsd:double
    | xsd:token { pattern = "(\-?[\d]+/\-?[\d]+)" }
    | xsd:decimal
  }?
att.resourced.attributes = att.resourced.attribute.url
att.resourced.attribute.url =
  
  ## (uniform resource locator) specifies the URL from which the media concerned may be obtained.
  attribute url { xsd:anyURI }
att.interpLike.attributes =
  att.interpLike.attribute.type, att.interpLike.attribute.inst
att.interpLike.attribute.type =
  
  ## indicates what kind of phenomenon is being noted in the passage.
  ## Sample values include: 1] image; 2] character; 3] theme; 4] allusion
  attribute type {
    xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
  }?
att.interpLike.attribute.inst =
  
  ## (instances) points to instances of the analysis or interpretation represented by the current element.
  attribute inst {
    list { xsd:anyURI+ }
  }?
att.measurement.attributes =
  att.measurement.attribute.unit,
  att.measurement.attribute.quantity,
  att.measurement.attribute.commodity
att.measurement.attribute.unit =
  
  ## indicates the units used for the measurement, usually using the standard symbol for the desired units.
  ## Suggested values include: 1] m (metre) ; 2] kg (kilogram) ; 3] s (second) ; 4] Hz (hertz) ; 5] Pa (pascal) ; 6] Ω (ohm) ; 7] L (litre) ; 8] t (tonne) ; 9] ha (hectare) ; 10] Å (ångström) ; 11] mL (millilitre) ; 12] cm (centimetre) ; 13] dB (decibel) ; 14] kbit (kilobit) ; 15] Kibit (kibibit) ; 16] kB (kilobyte) ; 17] KiB (kibibyte) ; 18] MB (megabyte) ; 19] MiB (mebibyte) 
  attribute unit {
    
    ## (metre) SI base unit of length
    "m"
    | 
      ## (kilogram) SI base unit of mass
      "kg"
    | 
      ## (second) SI base unit of time
      "s"
    | 
      ## (hertz) SI unit of frequency
      "Hz"
    | 
      ## (pascal) SI unit of pressure or stress
      "Pa"
    | 
      ## (ohm) SI unit of electric resistance
      "Ω"
    | 
      ## (litre) 1 dm³
      "L"
    | 
      ## (tonne) 10³ kg
      "t"
    | 
      ## (hectare) 1 hm²
      "ha"
    | 
      ## (ångström) 10⁻¹⁰ m
      "Å"
    | 
      ## (millilitre) 
      "mL"
    | 
      ## (centimetre) 
      "cm"
    | 
      ## (decibel) see remarks, below
      "dB"
    | 
      ## (kilobit) 10³ or 1000 bits
      "kbit"
    | 
      ## (kibibit) 2¹⁰ or 1024 bits
      "Kibit"
    | 
      ## (kilobyte) 10³ or 1000 bytes
      "kB"
    | 
      ## (kibibyte) 2¹⁰ or 1024 bytes
      "KiB"
    | 
      ## (megabyte) 10⁶ or 1 000 000 bytes
      "MB"
    | 
      ## (mebibyte) 2²⁰ or 1 048 576 bytes
      "MiB"
    | xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
  }?
att.measurement.attribute.quantity =
  
  ## specifies the number of the specified units that comprise the measurement
  attribute quantity {
    xsd:double
    | xsd:token { pattern = "(\-?[\d]+/\-?[\d]+)" }
    | xsd:decimal
  }?
att.measurement.attribute.commodity =
  
  ## indicates the substance that is being measured
  attribute commodity {
    list {
      xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }+
    }
  }?
att.naming.attributes =
  att.canonical.attributes,
  att.naming.attribute.role,
  att.naming.attribute.nymRef
att.naming.attribute.role =
  
  ## may be used to specify further information about the entity referenced by this name in the form of a set of whitespace-separated values, for example the occupation of a person, or the status of a place.
  attribute role {
    list {
      xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }+
    }
  }?
att.naming.attribute.nymRef =
  
  ## (reference to the canonical name) provides a means of locating the canonical form (nym) of the names associated with the object named by the element bearing it.
  attribute nymRef {
    list { xsd:anyURI+ }
  }?
att.notated.attributes = att.notated.attribute.notation
att.notated.attribute.notation =
  
  ## names the notation used for the content of the element.
  attribute notation {
    xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
  }?
att.placement.attributes = att.placement.attribute.place
att.placement.attribute.place =
  
  ## specifies where this item is placed.
  ## Suggested values include: 1] below; 2] bottom; 3] margin; 4] top; 5] opposite; 6] overleaf; 7] above; 8] end; 9] inline; 10] inspace
  attribute place {
    list {
      (
       ## below the line
       "below"
       | 
         ## at the foot of the page
         "bottom"
       | 
         ## in the margin (left, right, or both)
         "margin"
       | 
         ## at the top of the page
         "top"
       | 
         ## on the opposite, i.e. facing, page
         "opposite"
       | 
         ## on the other side of the leaf
         "overleaf"
       | 
         ## above the line
         "above"
       | 
         ## at the end of e.g. chapter or volume.
         "end"
       | 
         ## within the body of the text.
         "inline"
       | 
         ## in a predefined space, for example left by an earlier scribe.
         "inspace"
       | xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" })+
    }
  }?
att.typed.attributes =
  att.typed.attribute.type, att.typed.attribute.subtype
att.typed.attribute.type =
  
  ## characterizes the element in some sense, using any convenient classification scheme or typology.
  attribute type {
    xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
  }?
att.typed.attribute.subtype =
  
  ## provides a sub-categorization of the element, if needed
  attribute subtype {
    xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
  }?
sch:pattern [
  id = "att.typed-subtypeTyped-constraint-rule-5"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "tei:*[@subtype]"
    "\x{a}" ~
    "        "
    sch:assert [
      test = "@type"
      "The "
      sch:name [ ]
      " element should not be categorized in detail with @subtype unless also categorized in general with @type"
    ]
    "\x{a}" ~
    "      "
  ]
  "\x{a}" ~
  "   "
]
att.pointing.attributes =
  att.pointing.attribute.targetLang,
  att.pointing.attribute.target,
  att.pointing.attribute.evaluate
att.pointing.attribute.targetLang =
  
  ## specifies the language of the content to be found at the destination referenced by target, using a language tag generated according to BCP 47.
  attribute targetLang {
    xsd:language
    | (
       ##
       "")
  }?
sch:pattern [
  id = "att.pointing-targetLang-targetLang-constraint-rule-6"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "tei:*[not(self::tei:schemaSpec)][@targetLang]"
    "\x{a}" ~
    "            "
    sch:assert [
      test = "@target"
      "@targetLang should only be used on "
      sch:name [ ]
      " if @target is specified."
    ]
    "\x{a}" ~
    "          "
  ]
  "\x{a}" ~
  "   "
]
att.pointing.attribute.target =
  
  ## specifies the destination of the reference by supplying one or more URI References
  attribute target {
    list { xsd:anyURI+ }
  }?
att.pointing.attribute.evaluate =
  
  ## specifies the intended meaning when the target of a pointer is itself a pointer.
  attribute evaluate {
    
    ## if the element pointed to is itself a pointer, then the target of that pointer will be taken, and so on, until an element is found which is not a pointer.
    "all"
    | 
      ## if the element pointed to is itself a pointer, then its target (whether a pointer or not) is taken as the target of this pointer.
      "one"
    | 
      ## no further evaluation of targets is carried out beyond that needed to find the element specified in the pointer's target.
      "none"
  }?
att.pointing.group.attributes =
  att.pointing.attributes,
  att.typed.attributes,
  att.pointing.group.attribute.domains,
  att.pointing.group.attribute.targFunc
att.pointing.group.attribute.domains =
  
  ## optionally specifies the identifiers of the elements within which all elements indicated by the contents of this element lie.
  attribute domains {
    list { xsd:anyURI, xsd:anyURI, xsd:anyURI* }
  }?
att.pointing.group.attribute.targFunc =
  
  ## (target function) describes the function of each of the values of the target attribute of the enclosed link, join, or alt tags.
  attribute targFunc {
    list {
      xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" },
      xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" },
      xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }*
    }
  }?
att.scoping.attributes =
  att.scoping.attribute.target, att.scoping.attribute.match
att.scoping.attribute.target =
  
  ## points at one or several elements or sets of elements by means of one or more data pointers, using the URI syntax.
  attribute target {
    list { xsd:anyURI+ }
  }?
att.scoping.attribute.match =
  
  ## supplies an arbitrary XPath expression using the syntax defined in  which identifies a set of nodes, selected within the context identified by the target attribute if this is supplied, or within the context of the parent element if it is not.
  attribute match { text }?
att.segLike.attributes =
  att.metrical.attributes,
  att.datcat.attributes,
  att.fragmentable.attributes,
  att.segLike.attribute.function
att.segLike.attribute.function =
  
  ## characterizes the function of the segment.
  attribute function {
    xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
  }?
att.sortable.attributes = att.sortable.attribute.sortKey
att.sortable.attribute.sortKey =
  
  ## supplies the sort key for this element in an index, list or group which contains it.
  attribute sortKey {
    xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
  }?
att.edition.attributes =
  att.edition.attribute.ed, att.edition.attribute.edRef
att.edition.attribute.ed =
  
  ## (edition) supplies a sigil or other arbitrary identifier for the source edition in which the associated feature (for example, a page, column, or line break) occurs at this point in the text.
  attribute ed {
    list {
      xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }+
    }
  }?
att.edition.attribute.edRef =
  
  ## (edition reference) provides a pointer to the source edition in which the associated feature (for example, a page, column, or line break) occurs at this point in the text.
  attribute edRef {
    list { xsd:anyURI+ }
  }?
att.spanning.attributes = att.spanning.attribute.spanTo
att.spanning.attribute.spanTo =
  
  ## indicates the end of a span initiated by the element bearing this attribute.
  attribute spanTo { xsd:anyURI }?
sch:pattern [
  id = "att.spanning-spanTo-spanTo-2-constraint-rule-7"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "tei:*[@spanTo]"
    "\x{a}" ~
    "            "
    sch:assert [
      test =
        "id(substring(@spanTo,2)) and following::*[@xml:id=substring(current()/@spanTo,2)]"
      "\x{a}" ~
      "The element indicated by @spanTo ("
      sch:value-of [ select = "@spanTo" ]
      ") must follow the current element "
      sch:name [ ]
      "\x{a}" ~
      "                  "
    ]
    "\x{a}" ~
    "          "
  ]
  "\x{a}" ~
  "   "
]
att.styleDef.attributes =
  att.styleDef.attribute.scheme, att.styleDef.attribute.schemeVersion
att.styleDef.attribute.scheme =
  
  ## identifies the language used to describe the rendition.
  attribute scheme {
    
    ## Cascading Stylesheet Language
    "css"
    | 
      ## Extensible Stylesheet Language Formatting Objects
      "xslfo"
    | 
      ## Informal free text description
      "free"
    | 
      ## A user-defined rendition description language
      "other"
  }?
att.styleDef.attribute.schemeVersion =
  
  ## supplies a version number for the style language provided in scheme.
  attribute schemeVersion {
    xsd:token { pattern = "[\d]+[a-z]*[\d]*(\.[\d]+[a-z]*[\d]*){0,3}" }
  }?
sch:pattern [
  id =
    "att.styleDef-schemeVersion-schemeVersionRequiresScheme-constraint-rule-8"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "tei:*[@schemeVersion]"
    "\x{a}" ~
    "            "
    sch:assert [
      test = "@scheme and not(@scheme = 'free')"
      "\x{a}" ~
      "              @schemeVersion can only be used if @scheme is specified.\x{a}" ~
      "            "
    ]
    "\x{a}" ~
    "          "
  ]
  "\x{a}" ~
  "   "
]
att.timed.attributes =
  att.duration.attributes,
  att.timed.attribute.start,
  att.timed.attribute.end
att.timed.attribute.start =
  
  ## indicates the location within a temporal alignment at which this element begins.
  attribute start { xsd:anyURI }?
att.timed.attribute.end =
  
  ## indicates the location within a temporal alignment at which this element ends.
  attribute end { xsd:anyURI }?
att.transcriptional.attributes =
  att.editLike.attributes,
  att.written.attributes,
  att.transcriptional.attribute.status,
  att.transcriptional.attribute.cause,
  att.transcriptional.attribute.seq
att.transcriptional.attribute.status =
  
  ## indicates the effect of the intervention, for example in the case of a deletion, strikeouts which include too much or too little text, or in the case of an addition, an insertion which duplicates some of the text already present.
  ## Sample values include: 1] duplicate; 2] duplicate-partial; 3] excessStart; 4] excessEnd; 5] shortStart; 6] shortEnd; 7] partial; 8] unremarkable
  [ a:defaultValue = "unremarkable" ]
  attribute status {
    xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
  }?
att.transcriptional.attribute.cause =
  
  ## documents the presumed cause for the intervention.
  attribute cause {
    xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
  }?
att.transcriptional.attribute.seq =
  
  ## (sequence) assigns a sequence number related to the order in which the encoded features carrying this attribute are believed to have occurred.
  attribute seq { xsd:nonNegativeInteger }?
att.translatable.attributes = att.translatable.attribute.versionDate
att.translatable.attribute.versionDate =
  
  ## specifies the date on which the source text was extracted and sent to the translator
  attribute versionDate {
    xsd:date
    | xsd:gYear
    | xsd:gMonth
    | xsd:gDay
    | xsd:gYearMonth
    | xsd:gMonthDay
    | xsd:time
    | xsd:dateTime
  }?
att.citing.attributes =
  att.citing.attribute.unit,
  att.citing.attribute.from,
  att.citing.attribute.to
att.citing.attribute.unit =
  
  ## identifies the unit of information conveyed by the element, e.g. columns, pages, volume, entry.
  ## Suggested values include: 1] volume; 2] issue; 3] page; 4] line; 5] chapter; 6] part; 7] column; 8] entry
  attribute unit {
    
    ## the element contains a volume number.
    "volume"
    | 
      ## the element contains an issue number, or volume and issue numbers.
      "issue"
    | 
      ## the element contains a page number or page range.
      "page"
    | 
      ## the element contains a line number or line range.
      "line"
    | 
      ## the element contains a chapter indication (number and/or title)
      "chapter"
    | 
      ## the element identifies a part of a book or collection.
      "part"
    | 
      ## the element identifies a column.
      "column"
    | 
      ## the element identifies an entry number or label in a list of entries.
      "entry"
    | xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
  }?
att.citing.attribute.from =
  
  ## specifies the starting point of the range of units indicated by the unit attribute.
  attribute from {
    xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
  }?
att.citing.attribute.to =
  
  ## specifies the end-point of the range of units indicated by the unit attribute.
  attribute to {
    xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
  }?
model.nameLike.agent = name | orgName | persName
model.nameLike.agent_alternation = name | orgName | persName
model.nameLike.agent_sequence = name, orgName, persName
model.nameLike.agent_sequenceOptional = name?, orgName?, persName?
model.nameLike.agent_sequenceOptionalRepeatable =
  name*, orgName*, persName*
model.nameLike.agent_sequenceRepeatable = name+, orgName+, persName+
model.segLike = seg | s | cl | phr | w | m | c | pc
model.segLike_alternation = seg | s | cl | phr | w | m | c | pc
model.segLike_sequence = seg, s, cl, phr, w, m, c, pc
model.segLike_sequenceOptional = seg?, s?, cl?, phr?, w?, m?, c?, pc?
model.segLike_sequenceOptionalRepeatable =
  seg*, s*, cl*, phr*, w*, m*, c*, pc*
model.segLike_sequenceRepeatable = seg+, s+, cl+, phr+, w+, m+, c+, pc+
model.hiLike = hi
model.hiLike_alternation = hi
model.hiLike_sequence = hi
model.hiLike_sequenceOptional = hi?
model.hiLike_sequenceOptionalRepeatable = hi*
model.hiLike_sequenceRepeatable = hi+
model.emphLike =
  foreign
  | emph
  | distinct
  | mentioned
  | soCalled
  | gloss
  | term
  | title
  | code
  | ident
model.emphLike_alternation =
  foreign
  | emph
  | distinct
  | mentioned
  | soCalled
  | gloss
  | term
  | title
  | code
  | ident
model.emphLike_sequence =
  foreign,
  emph,
  distinct,
  mentioned,
  soCalled,
  gloss,
  term,
  title,
  code,
  ident
model.emphLike_sequenceOptional =
  foreign?,
  emph?,
  distinct?,
  mentioned?,
  soCalled?,
  gloss?,
  term?,
  title?,
  code?,
  ident?
model.emphLike_sequenceOptionalRepeatable =
  foreign*,
  emph*,
  distinct*,
  mentioned*,
  soCalled*,
  gloss*,
  term*,
  title*,
  code*,
  ident*
model.emphLike_sequenceRepeatable =
  foreign+,
  emph+,
  distinct+,
  mentioned+,
  soCalled+,
  gloss+,
  term+,
  title+,
  code+,
  ident+
model.highlighted = model.hiLike | model.emphLike
model.highlighted_alternation =
  model.hiLike_alternation | model.emphLike_alternation
model.highlighted_sequence =
  model.hiLike_sequence, model.emphLike_sequence
model.highlighted_sequenceOptional =
  model.hiLike_sequenceOptional?, model.emphLike_sequenceOptional?
model.highlighted_sequenceOptionalRepeatable =
  model.hiLike_sequenceOptionalRepeatable*,
  model.emphLike_sequenceOptionalRepeatable*
model.highlighted_sequenceRepeatable =
  model.hiLike_sequenceRepeatable+, model.emphLike_sequenceRepeatable+
model.dateLike = date | time
model.dateLike_alternation = date | time
model.dateLike_sequence = date, time
model.dateLike_sequenceOptional = date?, time?
model.dateLike_sequenceOptionalRepeatable = date*, time*
model.dateLike_sequenceRepeatable = date+, time+
model.dimLike = height | depth | width
model.dimLike_alternation = height | depth | width
model.dimLike_sequence = height, depth, width
model.dimLike_sequenceOptional = height?, depth?, width?
model.dimLike_sequenceOptionalRepeatable = height*, depth*, width*
model.dimLike_sequenceRepeatable = height+, depth+, width+
model.measureLike =
  num | measure | measureGrp | unit | dim | height | depth | width | geo
model.measureLike_alternation =
  num | measure | measureGrp | unit | dim | height | depth | width | geo
model.measureLike_sequence =
  num, measure, measureGrp, unit, dim, height, depth, width, geo
model.measureLike_sequenceOptional =
  num?,
  measure?,
  measureGrp?,
  unit?,
  dim?,
  height?,
  depth?,
  width?,
  geo?
model.measureLike_sequenceOptionalRepeatable =
  num*,
  measure*,
  measureGrp*,
  unit*,
  dim*,
  height*,
  depth*,
  width*,
  geo*
model.measureLike_sequenceRepeatable =
  num+,
  measure+,
  measureGrp+,
  unit+,
  dim+,
  height+,
  depth+,
  width+,
  geo+
model.egLike = eg | egXML
model.egLike_alternation = eg | egXML
model.egLike_sequence = eg, egXML
model.egLike_sequenceOptional = eg?, egXML?
model.egLike_sequenceOptionalRepeatable = eg*, egXML*
model.egLike_sequenceRepeatable = eg+, egXML+
model.graphicLike = media | graphic | binaryObject | formula
model.graphicLike_alternation = media | graphic | binaryObject | formula
model.graphicLike_sequence = media, graphic, binaryObject, formula
model.graphicLike_sequenceOptional =
  media?, graphic?, binaryObject?, formula?
model.graphicLike_sequenceOptionalRepeatable =
  media*, graphic*, binaryObject*, formula*
model.graphicLike_sequenceRepeatable =
  media+, graphic+, binaryObject+, formula+
model.offsetLike = offset | geogFeat
model.offsetLike_alternation = offset | geogFeat
model.offsetLike_sequence = offset, geogFeat
model.offsetLike_sequenceOptional = offset?, geogFeat?
model.offsetLike_sequenceOptionalRepeatable = offset*, geogFeat*
model.offsetLike_sequenceRepeatable = offset+, geogFeat+
model.pPart.msdesc =
  catchwords
  | dimensions
  | heraldry
  | locus
  | locusGrp
  | material
  | objectType
  | origDate
  | origPlace
  | secFol
  | signatures
  | stamp
  | watermark
model.pPart.msdesc_alternation =
  catchwords
  | dimensions
  | heraldry
  | locus
  | locusGrp
  | material
  | objectType
  | origDate
  | origPlace
  | secFol
  | signatures
  | stamp
  | watermark
model.pPart.msdesc_sequence =
  catchwords,
  dimensions,
  heraldry,
  locus,
  locusGrp,
  material,
  objectType,
  origDate,
  origPlace,
  secFol,
  signatures,
  stamp,
  watermark
model.pPart.msdesc_sequenceOptional =
  catchwords?,
  dimensions?,
  heraldry?,
  locus?,
  locusGrp?,
  material?,
  objectType?,
  origDate?,
  origPlace?,
  secFol?,
  signatures?,
  stamp?,
  watermark?
model.pPart.msdesc_sequenceOptionalRepeatable =
  catchwords*,
  dimensions*,
  heraldry*,
  locus*,
  locusGrp*,
  material*,
  objectType*,
  origDate*,
  origPlace*,
  secFol*,
  signatures*,
  stamp*,
  watermark*
model.pPart.msdesc_sequenceRepeatable =
  catchwords+,
  dimensions+,
  heraldry+,
  locus+,
  locusGrp+,
  material+,
  objectType+,
  origDate+,
  origPlace+,
  secFol+,
  signatures+,
  stamp+,
  watermark+
model.pPart.editorial = choice | abbr | expan | ex | am | subst
model.pPart.editorial_alternation =
  choice | abbr | expan | ex | am | subst
model.pPart.editorial_sequence = choice, abbr, expan, ex, am, subst
model.pPart.editorial_sequenceOptional =
  choice?, abbr?, expan?, ex?, am?, subst?
model.pPart.editorial_sequenceOptionalRepeatable =
  choice*, abbr*, expan*, ex*, am*, subst*
model.pPart.editorial_sequenceRepeatable =
  choice+, abbr+, expan+, ex+, am+, subst+
model.pPart.transcriptional =
  sic
  | corr
  | reg
  | orig
  | add
  | del
  | unclear
  | damage
  | handShift
  | restore
  | supplied
  | surplus
  | secl
  | mod
  | redo
  | retrace
  | undo
model.pPart.transcriptional_alternation =
  sic
  | corr
  | reg
  | orig
  | add
  | del
  | unclear
  | damage
  | handShift
  | restore
  | supplied
  | surplus
  | secl
  | mod
  | redo
  | retrace
  | undo
model.pPart.transcriptional_sequence =
  sic,
  corr,
  reg,
  orig,
  add,
  del,
  unclear,
  damage,
  handShift,
  restore,
  supplied,
  surplus,
  secl,
  mod,
  redo,
  retrace,
  undo
model.pPart.transcriptional_sequenceOptional =
  sic?,
  corr?,
  reg?,
  orig?,
  add?,
  del?,
  unclear?,
  damage?,
  handShift?,
  restore?,
  supplied?,
  surplus?,
  secl?,
  mod?,
  redo?,
  retrace?,
  undo?
model.pPart.transcriptional_sequenceOptionalRepeatable =
  sic*,
  corr*,
  reg*,
  orig*,
  add*,
  del*,
  unclear*,
  damage*,
  handShift*,
  restore*,
  supplied*,
  surplus*,
  secl*,
  mod*,
  redo*,
  retrace*,
  undo*
model.pPart.transcriptional_sequenceRepeatable =
  sic+,
  corr+,
  reg+,
  orig+,
  add+,
  del+,
  unclear+,
  damage+,
  handShift+,
  restore+,
  supplied+,
  surplus+,
  secl+,
  mod+,
  redo+,
  retrace+,
  undo+
model.pPart.edit = model.pPart.editorial | model.pPart.transcriptional
model.pPart.edit_alternation =
  model.pPart.editorial_alternation
  | model.pPart.transcriptional_alternation
model.pPart.edit_sequence =
  model.pPart.editorial_sequence, model.pPart.transcriptional_sequence
model.pPart.edit_sequenceOptional =
  model.pPart.editorial_sequenceOptional?,
  model.pPart.transcriptional_sequenceOptional?
model.pPart.edit_sequenceOptionalRepeatable =
  model.pPart.editorial_sequenceOptionalRepeatable*,
  model.pPart.transcriptional_sequenceOptionalRepeatable*
model.pPart.edit_sequenceRepeatable =
  model.pPart.editorial_sequenceRepeatable+,
  model.pPart.transcriptional_sequenceRepeatable+
model.linePart =
  model.hiLike
  | choice
  | add
  | del
  | unclear
  | zone
  | path
  | damage
  | handShift
  | restore
  | line
  | mod
  | redo
  | retrace
  | undo
  | seg
  | w
  | c
  | pc
model.linePart_alternation =
  model.hiLike_alternation
  | choice
  | add
  | del
  | unclear
  | zone
  | path
  | damage
  | handShift
  | restore
  | line
  | mod
  | redo
  | retrace
  | undo
  | seg
  | w
  | c
  | pc
model.linePart_sequence =
  model.hiLike_sequence,
  choice,
  add,
  del,
  unclear,
  zone,
  path,
  damage,
  handShift,
  restore,
  line,
  mod,
  redo,
  retrace,
  undo,
  seg,
  w,
  c,
  pc
model.linePart_sequenceOptional =
  model.hiLike_sequenceOptional?,
  choice?,
  add?,
  del?,
  unclear?,
  zone?,
  path?,
  damage?,
  handShift?,
  restore?,
  line?,
  mod?,
  redo?,
  retrace?,
  undo?,
  seg?,
  w?,
  c?,
  pc?
model.linePart_sequenceOptionalRepeatable =
  model.hiLike_sequenceOptionalRepeatable*,
  choice*,
  add*,
  del*,
  unclear*,
  zone*,
  path*,
  damage*,
  handShift*,
  restore*,
  line*,
  mod*,
  redo*,
  retrace*,
  undo*,
  seg*,
  w*,
  c*,
  pc*
model.linePart_sequenceRepeatable =
  model.hiLike_sequenceRepeatable+,
  choice+,
  add+,
  del+,
  unclear+,
  zone+,
  path+,
  damage+,
  handShift+,
  restore+,
  line+,
  mod+,
  redo+,
  retrace+,
  undo+,
  seg+,
  w+,
  c+,
  pc+
model.ptrLike = ptr | ref
model.ptrLike_alternation = ptr | ref
model.ptrLike_sequence = ptr, ref
model.ptrLike_sequenceOptional = ptr?, ref?
model.ptrLike_sequenceOptionalRepeatable = ptr*, ref*
model.ptrLike_sequenceRepeatable = ptr+, ref+
model.lPart = caesura | rhyme
model.lPart_alternation = caesura | rhyme
model.lPart_sequence = caesura, rhyme
model.lPart_sequenceOptional = caesura?, rhyme?
model.lPart_sequenceOptionalRepeatable = caesura*, rhyme*
model.lPart_sequenceRepeatable = caesura+, rhyme+
model.global.meta =
  index
  | substJoin
  | listTranspose
  | link
  | linkGrp
  | timeline
  | join
  | joinGrp
  | alt
  | altGrp
  | span
  | spanGrp
  | interp
  | interpGrp
  | fs
  | fLib
  | fvLib
  | precision
  | certainty
  | respons
model.global.meta_alternation =
  index
  | substJoin
  | listTranspose
  | link
  | linkGrp
  | timeline
  | join
  | joinGrp
  | alt
  | altGrp
  | span
  | spanGrp
  | interp
  | interpGrp
  | fs
  | fLib
  | fvLib
  | precision
  | certainty
  | respons
model.global.meta_sequence =
  index,
  substJoin,
  listTranspose,
  link,
  linkGrp,
  timeline,
  join,
  joinGrp,
  alt,
  altGrp,
  span,
  spanGrp,
  interp,
  interpGrp,
  fs,
  fLib,
  fvLib,
  precision,
  certainty,
  respons
model.global.meta_sequenceOptional =
  index?,
  substJoin?,
  listTranspose?,
  link?,
  linkGrp?,
  timeline?,
  join?,
  joinGrp?,
  alt?,
  altGrp?,
  span?,
  spanGrp?,
  interp?,
  interpGrp?,
  fs?,
  fLib?,
  fvLib?,
  precision?,
  certainty?,
  respons?
model.global.meta_sequenceOptionalRepeatable =
  index*,
  substJoin*,
  listTranspose*,
  link*,
  linkGrp*,
  timeline*,
  join*,
  joinGrp*,
  alt*,
  altGrp*,
  span*,
  spanGrp*,
  interp*,
  interpGrp*,
  fs*,
  fLib*,
  fvLib*,
  precision*,
  certainty*,
  respons*
model.global.meta_sequenceRepeatable =
  index+,
  substJoin+,
  listTranspose+,
  link+,
  linkGrp+,
  timeline+,
  join+,
  joinGrp+,
  alt+,
  altGrp+,
  span+,
  spanGrp+,
  interp+,
  interpGrp+,
  fs+,
  fLib+,
  fvLib+,
  precision+,
  certainty+,
  respons+
model.milestoneLike = milestone | gb | pb | lb | cb | fw | anchor
model.milestoneLike_alternation =
  milestone | gb | pb | lb | cb | fw | anchor
model.milestoneLike_sequence = milestone, gb, pb, lb, cb, fw, anchor
model.milestoneLike_sequenceOptional =
  milestone?, gb?, pb?, lb?, cb?, fw?, anchor?
model.milestoneLike_sequenceOptionalRepeatable =
  milestone*, gb*, pb*, lb*, cb*, fw*, anchor*
model.milestoneLike_sequenceRepeatable =
  milestone+, gb+, pb+, lb+, cb+, fw+, anchor+
model.gLike = g
model.gLike_alternation = g
model.gLike_sequence = g
model.gLike_sequenceOptional = g?
model.gLike_sequenceOptionalRepeatable = g*
model.gLike_sequenceRepeatable = g+
model.oddDecl =
  moduleSpec
  | specGrp
  | specGrpRef
  | elementSpec
  | classSpec
  | dataSpec
  | macroSpec
  | listRef
  | outputRendition
  | constraintSpec
model.oddDecl_alternation =
  moduleSpec
  | specGrp
  | specGrpRef
  | elementSpec
  | classSpec
  | dataSpec
  | macroSpec
  | listRef
  | outputRendition
  | constraintSpec
model.oddDecl_sequence =
  moduleSpec,
  specGrp,
  specGrpRef,
  elementSpec,
  classSpec,
  dataSpec,
  macroSpec,
  listRef,
  outputRendition,
  constraintSpec
model.oddDecl_sequenceOptional =
  moduleSpec?,
  specGrp?,
  specGrpRef?,
  elementSpec?,
  classSpec?,
  dataSpec?,
  macroSpec?,
  listRef?,
  outputRendition?,
  constraintSpec?
model.oddDecl_sequenceOptionalRepeatable =
  moduleSpec*,
  specGrp*,
  specGrpRef*,
  elementSpec*,
  classSpec*,
  dataSpec*,
  macroSpec*,
  listRef*,
  outputRendition*,
  constraintSpec*
model.oddDecl_sequenceRepeatable =
  moduleSpec+,
  specGrp+,
  specGrpRef+,
  elementSpec+,
  classSpec+,
  dataSpec+,
  macroSpec+,
  listRef+,
  outputRendition+,
  constraintSpec+
model.oddRef = classRef | elementRef | macroRef | moduleRef | dataRef
model.oddRef_alternation =
  classRef | elementRef | macroRef | moduleRef | dataRef
model.oddRef_sequence =
  classRef, elementRef, macroRef, moduleRef, dataRef
model.oddRef_sequenceOptional =
  classRef?, elementRef?, macroRef?, moduleRef?, dataRef?
model.oddRef_sequenceOptionalRepeatable =
  classRef*, elementRef*, macroRef*, moduleRef*, dataRef*
model.oddRef_sequenceRepeatable =
  classRef+, elementRef+, macroRef+, moduleRef+, dataRef+
model.phrase.xml = att | gi | tag | val
model.phrase.xml_alternation = att | gi | tag | val
model.phrase.xml_sequence = att, gi, tag, val
model.phrase.xml_sequenceOptional = att?, gi?, tag?, val?
model.phrase.xml_sequenceOptionalRepeatable = att*, gi*, tag*, val*
model.phrase.xml_sequenceRepeatable = att+, gi+, tag+, val+
model.specDescLike = specList | specDesc
model.specDescLike_alternation = specList | specDesc
model.specDescLike_sequence = specList, specDesc
model.specDescLike_sequenceOptional = specList?, specDesc?
model.specDescLike_sequenceOptionalRepeatable = specList*, specDesc*
model.specDescLike_sequenceRepeatable = specList+, specDesc+
model.biblLike = biblFull | bibl | biblStruct | listBibl | msDesc
model.biblLike_alternation =
  biblFull | bibl | biblStruct | listBibl | msDesc
model.biblLike_sequence = biblFull, bibl, biblStruct, listBibl, msDesc
model.biblLike_sequenceOptional =
  biblFull?, bibl?, biblStruct?, listBibl?, msDesc?
model.biblLike_sequenceOptionalRepeatable =
  biblFull*, bibl*, biblStruct*, listBibl*, msDesc*
model.biblLike_sequenceRepeatable =
  biblFull+, bibl+, biblStruct+, listBibl+, msDesc+
model.headLike = head
model.headLike_alternation = head
model.headLike_sequence = head
model.headLike_sequenceOptional = head?
model.headLike_sequenceOptionalRepeatable = head*
model.headLike_sequenceRepeatable = head+
model.labelLike = desc | label
model.labelLike_alternation = desc | label
model.labelLike_sequence = desc, label
model.labelLike_sequenceOptional = desc?, label?
model.labelLike_sequenceOptionalRepeatable = desc*, label*
model.labelLike_sequenceRepeatable = desc+, label+
model.listLike =
  \list
  | listApp
  | listWit
  | listOrg
  | listEvent
  | listPerson
  | listPlace
  | listRelation
  | listObject
  | listNym
  | table
model.listLike_alternation =
  \list
  | listApp
  | listWit
  | listOrg
  | listEvent
  | listPerson
  | listPlace
  | listRelation
  | listObject
  | listNym
  | table
model.listLike_sequence =
  \list,
  listApp,
  listWit,
  listOrg,
  listEvent,
  listPerson,
  listPlace,
  listRelation,
  listObject,
  listNym,
  table
model.listLike_sequenceOptional =
  \list?,
  listApp?,
  listWit?,
  listOrg?,
  listEvent?,
  listPerson?,
  listPlace?,
  listRelation?,
  listObject?,
  listNym?,
  table?
model.listLike_sequenceOptionalRepeatable =
  \list*,
  listApp*,
  listWit*,
  listOrg*,
  listEvent*,
  listPerson*,
  listPlace*,
  listRelation*,
  listObject*,
  listNym*,
  table*
model.listLike_sequenceRepeatable =
  \list+,
  listApp+,
  listWit+,
  listOrg+,
  listEvent+,
  listPerson+,
  listPlace+,
  listRelation+,
  listObject+,
  listNym+,
  table+
model.noteLike = note
model.noteLike_alternation = note
model.noteLike_sequence = note
model.noteLike_sequenceOptional = note?
model.noteLike_sequenceOptionalRepeatable = note*
model.noteLike_sequenceRepeatable = note+
model.lLike = l
model.lLike_alternation = l
model.lLike_sequence = l
model.lLike_sequenceOptional = l?
model.lLike_sequenceOptionalRepeatable = l*
model.lLike_sequenceRepeatable = l+
model.pLike = p | ab
model.pLike_alternation = p | ab
model.pLike_sequence = p, ab
model.pLike_sequenceOptional = p?, ab?
model.pLike_sequenceOptionalRepeatable = p*, ab*
model.pLike_sequenceRepeatable = p+, ab+
model.stageLike = stage | move | view | camera | sound | caption | tech
model.stageLike_alternation =
  stage | move | view | camera | sound | caption | tech
model.stageLike_sequence =
  stage, move, view, camera, sound, caption, tech
model.stageLike_sequenceOptional =
  stage?, move?, view?, camera?, sound?, caption?, tech?
model.stageLike_sequenceOptionalRepeatable =
  stage*, move*, view*, camera*, sound*, caption*, tech*
model.stageLike_sequenceRepeatable =
  stage+, move+, view+, camera+, sound+, caption+, tech+
model.featureVal.complex = fs | vColl | vNot | vMerge
model.featureVal.complex_alternation = fs | vColl | vNot | vMerge
model.featureVal.complex_sequence = fs, vColl, vNot, vMerge
model.featureVal.complex_sequenceOptional = fs?, vColl?, vNot?, vMerge?
model.featureVal.complex_sequenceOptionalRepeatable =
  fs*, vColl*, vNot*, vMerge*
model.featureVal.complex_sequenceRepeatable =
  fs+, vColl+, vNot+, vMerge+
model.featureVal.single =
  binary | symbol | numeric | \string | vLabel | \default | vAlt
model.featureVal.single_alternation =
  binary | symbol | numeric | \string | vLabel | \default | vAlt
model.featureVal.single_sequence =
  binary, symbol, numeric, \string, vLabel, \default, vAlt
model.featureVal.single_sequenceOptional =
  binary?, symbol?, numeric?, \string?, vLabel?, \default?, vAlt?
model.featureVal.single_sequenceOptionalRepeatable =
  binary*, symbol*, numeric*, \string*, vLabel*, \default*, vAlt*
model.featureVal.single_sequenceRepeatable =
  binary+, symbol+, numeric+, \string+, vLabel+, \default+, vAlt+
model.entryPart =
  superEntry
  | hom
  | sense
  | form
  | orth
  | pron
  | hyph
  | syll
  | gramGrp
  | pos
  | subc
  | colloc
  | def
  | etym
  | usg
  | lbl
  | xr
  | re
model.entryPart_alternation =
  superEntry
  | hom
  | sense
  | form
  | orth
  | pron
  | hyph
  | syll
  | gramGrp
  | pos
  | subc
  | colloc
  | def
  | etym
  | usg
  | lbl
  | xr
  | re
model.entryPart_sequence =
  superEntry,
  hom,
  sense,
  form,
  orth,
  pron,
  hyph,
  syll,
  gramGrp,
  pos,
  subc,
  colloc,
  def,
  etym,
  usg,
  lbl,
  xr,
  re
model.entryPart_sequenceOptional =
  superEntry?,
  hom?,
  sense?,
  form?,
  orth?,
  pron?,
  hyph?,
  syll?,
  gramGrp?,
  pos?,
  subc?,
  colloc?,
  def?,
  etym?,
  usg?,
  lbl?,
  xr?,
  re?
model.entryPart_sequenceOptionalRepeatable =
  superEntry*,
  hom*,
  sense*,
  form*,
  orth*,
  pron*,
  hyph*,
  syll*,
  gramGrp*,
  pos*,
  subc*,
  colloc*,
  def*,
  etym*,
  usg*,
  lbl*,
  xr*,
  re*
model.entryPart_sequenceRepeatable =
  superEntry+,
  hom+,
  sense+,
  form+,
  orth+,
  pron+,
  hyph+,
  syll+,
  gramGrp+,
  pos+,
  subc+,
  colloc+,
  def+,
  etym+,
  usg+,
  lbl+,
  xr+,
  re+
model.entryPart.top =
  cit | dictScrap | form | gramGrp | def | etym | usg | lbl | xr | re
model.entryPart.top_alternation =
  cit | dictScrap | form | gramGrp | def | etym | usg | lbl | xr | re
model.entryPart.top_sequence =
  cit, dictScrap, form, gramGrp, def, etym, usg, lbl, xr, re
model.entryPart.top_sequenceOptional =
  cit?, dictScrap?, form?, gramGrp?, def?, etym?, usg?, lbl?, xr?, re?
model.entryPart.top_sequenceOptionalRepeatable =
  cit*, dictScrap*, form*, gramGrp*, def*, etym*, usg*, lbl*, xr*, re*
model.entryPart.top_sequenceRepeatable =
  cit+, dictScrap+, form+, gramGrp+, def+, etym+, usg+, lbl+, xr+, re+
model.eventLike = event | listEvent
model.eventLike_alternation = event | listEvent
model.eventLike_sequence = event, listEvent
model.eventLike_sequenceOptional = event?, listEvent?
model.eventLike_sequenceOptionalRepeatable = event*, listEvent*
model.eventLike_sequenceRepeatable = event+, listEvent+
model.global.edit =
  gap | addSpan | damageSpan | delSpan | space | app | witDetail
model.global.edit_alternation =
  gap | addSpan | damageSpan | delSpan | space | app | witDetail
model.global.edit_sequence =
  gap, addSpan, damageSpan, delSpan, space, app, witDetail
model.global.edit_sequenceOptional =
  gap?, addSpan?, damageSpan?, delSpan?, space?, app?, witDetail?
model.global.edit_sequenceOptionalRepeatable =
  gap*, addSpan*, damageSpan*, delSpan*, space*, app*, witDetail*
model.global.edit_sequenceRepeatable =
  gap+, addSpan+, damageSpan+, delSpan+, space+, app+, witDetail+
model.divPart =
  model.lLike
  | model.pLike
  | lg
  | sp
  | spGrp
  | model.divPart.spoken
  | graph
  | tree
  | eTree
  | forest
  | listForest
  | schemaSpec
model.divPart_alternation =
  model.lLike_alternation
  | model.pLike_alternation
  | lg
  | sp
  | spGrp
  | model.divPart.spoken_alternation
  | graph
  | tree
  | eTree
  | forest
  | listForest
  | schemaSpec
model.divPart_sequence =
  model.lLike_sequence,
  model.pLike_sequence,
  lg,
  sp,
  spGrp,
  model.divPart.spoken_sequence,
  graph,
  tree,
  eTree,
  forest,
  listForest,
  schemaSpec
model.divPart_sequenceOptional =
  model.lLike_sequenceOptional?,
  model.pLike_sequenceOptional?,
  lg?,
  sp?,
  spGrp?,
  model.divPart.spoken_sequenceOptional?,
  graph?,
  tree?,
  eTree?,
  forest?,
  listForest?,
  schemaSpec?
model.divPart_sequenceOptionalRepeatable =
  model.lLike_sequenceOptionalRepeatable*,
  model.pLike_sequenceOptionalRepeatable*,
  lg*,
  sp*,
  spGrp*,
  model.divPart.spoken_sequenceOptionalRepeatable*,
  graph*,
  tree*,
  eTree*,
  forest*,
  listForest*,
  schemaSpec*
model.divPart_sequenceRepeatable =
  model.lLike_sequenceRepeatable+,
  model.pLike_sequenceRepeatable+,
  lg+,
  sp+,
  spGrp+,
  model.divPart.spoken_sequenceRepeatable+,
  graph+,
  tree+,
  eTree+,
  forest+,
  listForest+,
  schemaSpec+
model.persStateLike =
  persName
  | affiliation
  | age
  | education
  | faith
  | floruit
  | langKnowledge
  | nationality
  | occupation
  | persona
  | residence
  | sex
  | socecStatus
  | state
  | trait
model.persStateLike_alternation =
  persName
  | affiliation
  | age
  | education
  | faith
  | floruit
  | langKnowledge
  | nationality
  | occupation
  | persona
  | residence
  | sex
  | socecStatus
  | state
  | trait
model.persStateLike_sequence =
  persName,
  affiliation,
  age,
  education,
  faith,
  floruit,
  langKnowledge,
  nationality,
  occupation,
  persona,
  residence,
  sex,
  socecStatus,
  state,
  trait
model.persStateLike_sequenceOptional =
  persName?,
  affiliation?,
  age?,
  education?,
  faith?,
  floruit?,
  langKnowledge?,
  nationality?,
  occupation?,
  persona?,
  residence?,
  sex?,
  socecStatus?,
  state?,
  trait?
model.persStateLike_sequenceOptionalRepeatable =
  persName*,
  affiliation*,
  age*,
  education*,
  faith*,
  floruit*,
  langKnowledge*,
  nationality*,
  occupation*,
  persona*,
  residence*,
  sex*,
  socecStatus*,
  state*,
  trait*
model.persStateLike_sequenceRepeatable =
  persName+,
  affiliation+,
  age+,
  education+,
  faith+,
  floruit+,
  langKnowledge+,
  nationality+,
  occupation+,
  persona+,
  residence+,
  sex+,
  socecStatus+,
  state+,
  trait+
model.personLike = org | person | personGrp
model.personLike_alternation = org | person | personGrp
model.personLike_sequence = org, person, personGrp
model.personLike_sequenceOptional = org?, person?, personGrp?
model.personLike_sequenceOptionalRepeatable = org*, person*, personGrp*
model.personLike_sequenceRepeatable = org+, person+, personGrp+
model.personPart =
  model.biblLike
  | model.eventLike
  | model.persStateLike
  | idno
  | name
  | birth
  | death
model.personPart_alternation =
  model.biblLike_alternation
  | model.eventLike_alternation
  | model.persStateLike_alternation
  | idno
  | name
  | birth
  | death
model.personPart_sequence =
  model.biblLike_sequence,
  model.eventLike_sequence,
  model.persStateLike_sequence,
  idno,
  name,
  birth,
  death
model.personPart_sequenceOptional =
  model.biblLike_sequenceOptional?,
  model.eventLike_sequenceOptional?,
  model.persStateLike_sequenceOptional?,
  idno?,
  name?,
  birth?,
  death?
model.personPart_sequenceOptionalRepeatable =
  model.biblLike_sequenceOptionalRepeatable*,
  model.eventLike_sequenceOptionalRepeatable*,
  model.persStateLike_sequenceOptionalRepeatable*,
  idno*,
  name*,
  birth*,
  death*
model.personPart_sequenceRepeatable =
  model.biblLike_sequenceRepeatable+,
  model.eventLike_sequenceRepeatable+,
  model.persStateLike_sequenceRepeatable+,
  idno+,
  name+,
  birth+,
  death+
model.placeNamePart =
  placeName | bloc | country | region | settlement | district | geogName
model.placeNamePart_alternation =
  placeName | bloc | country | region | settlement | district | geogName
model.placeNamePart_sequence =
  placeName, bloc, country, region, settlement, district, geogName
model.placeNamePart_sequenceOptional =
  placeName?,
  bloc?,
  country?,
  region?,
  settlement?,
  district?,
  geogName?
model.placeNamePart_sequenceOptionalRepeatable =
  placeName*,
  bloc*,
  country*,
  region*,
  settlement*,
  district*,
  geogName*
model.placeNamePart_sequenceRepeatable =
  placeName+,
  bloc+,
  country+,
  region+,
  settlement+,
  district+,
  geogName+
model.placeStateLike =
  model.placeNamePart
  | climate
  | location
  | population
  | state
  | terrain
  | trait
model.placeStateLike_alternation =
  model.placeNamePart_alternation
  | climate
  | location
  | population
  | state
  | terrain
  | trait
model.placeStateLike_sequence =
  model.placeNamePart_sequence,
  climate,
  location,
  population,
  state,
  terrain,
  trait
model.placeStateLike_sequenceOptional =
  model.placeNamePart_sequenceOptional?,
  climate?,
  location?,
  population?,
  state?,
  terrain?,
  trait?
model.placeStateLike_sequenceOptionalRepeatable =
  model.placeNamePart_sequenceOptionalRepeatable*,
  climate*,
  location*,
  population*,
  state*,
  terrain*,
  trait*
model.placeStateLike_sequenceRepeatable =
  model.placeNamePart_sequenceRepeatable+,
  climate+,
  location+,
  population+,
  state+,
  terrain+,
  trait+
model.orgPart = model.eventLike | listOrg | listPerson | listPlace
model.orgPart_alternation =
  model.eventLike_alternation | listOrg | listPerson | listPlace
model.orgPart_sequence =
  model.eventLike_sequence, listOrg, listPerson, listPlace
model.orgPart_sequenceOptional =
  model.eventLike_sequenceOptional?, listOrg?, listPerson?, listPlace?
model.orgPart_sequenceOptionalRepeatable =
  model.eventLike_sequenceOptionalRepeatable*,
  listOrg*,
  listPerson*,
  listPlace*
model.orgPart_sequenceRepeatable =
  model.eventLike_sequenceRepeatable+, listOrg+, listPerson+, listPlace+
model.publicationStmtPart.agency = distributor | authority | publisher
model.publicationStmtPart.agency_alternation =
  distributor | authority | publisher
model.publicationStmtPart.agency_sequence =
  distributor, authority, publisher
model.publicationStmtPart.agency_sequenceOptional =
  distributor?, authority?, publisher?
model.publicationStmtPart.agency_sequenceOptionalRepeatable =
  distributor*, authority*, publisher*
model.publicationStmtPart.agency_sequenceRepeatable =
  distributor+, authority+, publisher+
model.publicationStmtPart.detail =
  model.ptrLike | idno | availability | address | date | pubPlace
model.publicationStmtPart.detail_alternation =
  model.ptrLike_alternation
  | idno
  | availability
  | address
  | date
  | pubPlace
model.publicationStmtPart.detail_sequence =
  model.ptrLike_sequence, idno, availability, address, date, pubPlace
model.publicationStmtPart.detail_sequenceOptional =
  model.ptrLike_sequenceOptional?,
  idno?,
  availability?,
  address?,
  date?,
  pubPlace?
model.publicationStmtPart.detail_sequenceOptionalRepeatable =
  model.ptrLike_sequenceOptionalRepeatable*,
  idno*,
  availability*,
  address*,
  date*,
  pubPlace*
model.publicationStmtPart.detail_sequenceRepeatable =
  model.ptrLike_sequenceRepeatable+,
  idno+,
  availability+,
  address+,
  date+,
  pubPlace+
model.availabilityPart = licence
model.availabilityPart_alternation = licence
model.availabilityPart_sequence = licence
model.availabilityPart_sequenceOptional = licence?
model.availabilityPart_sequenceOptionalRepeatable = licence*
model.availabilityPart_sequenceRepeatable = licence+
model.certLike = precision | certainty | respons
model.certLike_alternation = precision | certainty | respons
model.certLike_sequence = precision, certainty, respons
model.certLike_sequenceOptional = precision?, certainty?, respons?
model.certLike_sequenceOptionalRepeatable =
  precision*, certainty*, respons*
model.certLike_sequenceRepeatable = precision+, certainty+, respons+
model.descLike = desc
model.descLike_alternation = desc
model.descLike_sequence = desc
model.descLike_sequenceOptional = desc?
model.descLike_sequenceOptionalRepeatable = desc*
model.descLike_sequenceRepeatable = desc+
model.glossLike = gloss | equiv | altIdent
model.glossLike_alternation = gloss | equiv | altIdent
model.glossLike_sequence = gloss, equiv, altIdent
model.glossLike_sequenceOptional = gloss?, equiv?, altIdent?
model.glossLike_sequenceOptionalRepeatable = gloss*, equiv*, altIdent*
model.glossLike_sequenceRepeatable = gloss+, equiv+, altIdent+
model.quoteLike = quote | cit
model.quoteLike_alternation = quote | cit
model.quoteLike_sequence = quote, cit
model.quoteLike_sequenceOptional = quote?, cit?
model.quoteLike_sequenceOptionalRepeatable = quote*, cit*
model.quoteLike_sequenceRepeatable = quote+, cit+
model.qLike = model.quoteLike | said | q | floatingText
model.qLike_alternation =
  model.quoteLike_alternation | said | q | floatingText
model.qLike_sequence = model.quoteLike_sequence, said, q, floatingText
model.qLike_sequenceOptional =
  model.quoteLike_sequenceOptional?, said?, q?, floatingText?
model.qLike_sequenceOptionalRepeatable =
  model.quoteLike_sequenceOptionalRepeatable*, said*, q*, floatingText*
model.qLike_sequenceRepeatable =
  model.quoteLike_sequenceRepeatable+, said+, q+, floatingText+
model.respLike =
  sponsor | funder | principal | author | editor | respStmt | meeting
model.respLike_alternation =
  sponsor | funder | principal | author | editor | respStmt | meeting
model.respLike_sequence =
  sponsor, funder, principal, author, editor, respStmt, meeting
model.respLike_sequenceOptional =
  sponsor?, funder?, principal?, author?, editor?, respStmt?, meeting?
model.respLike_sequenceOptionalRepeatable =
  sponsor*, funder*, principal*, author*, editor*, respStmt*, meeting*
model.respLike_sequenceRepeatable =
  sponsor+, funder+, principal+, author+, editor+, respStmt+, meeting+
model.divWrapper =
  meeting
  | byline
  | dateline
  | argument
  | epigraph
  | salute
  | docAuthor
  | docDate
model.divWrapper_alternation =
  meeting
  | byline
  | dateline
  | argument
  | epigraph
  | salute
  | docAuthor
  | docDate
model.divWrapper_sequence =
  meeting,
  byline,
  dateline,
  argument,
  epigraph,
  salute,
  docAuthor,
  docDate
model.divWrapper_sequenceOptional =
  meeting?,
  byline?,
  dateline?,
  argument?,
  epigraph?,
  salute?,
  docAuthor?,
  docDate?
model.divWrapper_sequenceOptionalRepeatable =
  meeting*,
  byline*,
  dateline*,
  argument*,
  epigraph*,
  salute*,
  docAuthor*,
  docDate*
model.divWrapper_sequenceRepeatable =
  meeting+,
  byline+,
  dateline+,
  argument+,
  epigraph+,
  salute+,
  docAuthor+,
  docDate+
model.divTopPart = model.headLike | opener | signed
model.divTopPart_alternation =
  model.headLike_alternation | opener | signed
model.divTopPart_sequence = model.headLike_sequence, opener, signed
model.divTopPart_sequenceOptional =
  model.headLike_sequenceOptional?, opener?, signed?
model.divTopPart_sequenceOptionalRepeatable =
  model.headLike_sequenceOptionalRepeatable*, opener*, signed*
model.divTopPart_sequenceRepeatable =
  model.headLike_sequenceRepeatable+, opener+, signed+
model.divTop = model.divWrapper | model.divTopPart
model.divTop_alternation =
  model.divWrapper_alternation | model.divTopPart_alternation
model.divTop_sequence =
  model.divWrapper_sequence, model.divTopPart_sequence
model.divTop_sequenceOptional =
  model.divWrapper_sequenceOptional?, model.divTopPart_sequenceOptional?
model.divTop_sequenceOptionalRepeatable =
  model.divWrapper_sequenceOptionalRepeatable*,
  model.divTopPart_sequenceOptionalRepeatable*
model.divTop_sequenceRepeatable =
  model.divWrapper_sequenceRepeatable+,
  model.divTopPart_sequenceRepeatable+
model.frontPart.drama =
  set | prologue | epilogue | performance | castList
model.frontPart.drama_alternation =
  set | prologue | epilogue | performance | castList
model.frontPart.drama_sequence =
  set, prologue, epilogue, performance, castList
model.frontPart.drama_sequenceOptional =
  set?, prologue?, epilogue?, performance?, castList?
model.frontPart.drama_sequenceOptionalRepeatable =
  set*, prologue*, epilogue*, performance*, castList*
model.frontPart.drama_sequenceRepeatable =
  set+, prologue+, epilogue+, performance+, castList+
model.pLike.front =
  head
  | byline
  | argument
  | epigraph
  | docTitle
  | titlePart
  | docAuthor
  | docEdition
  | docImprint
  | docDate
model.pLike.front_alternation =
  head
  | byline
  | argument
  | epigraph
  | docTitle
  | titlePart
  | docAuthor
  | docEdition
  | docImprint
  | docDate
model.pLike.front_sequence =
  head,
  byline,
  argument,
  epigraph,
  docTitle,
  titlePart,
  docAuthor,
  docEdition,
  docImprint,
  docDate
model.pLike.front_sequenceOptional =
  head?,
  byline?,
  argument?,
  epigraph?,
  docTitle?,
  titlePart?,
  docAuthor?,
  docEdition?,
  docImprint?,
  docDate?
model.pLike.front_sequenceOptionalRepeatable =
  head*,
  byline*,
  argument*,
  epigraph*,
  docTitle*,
  titlePart*,
  docAuthor*,
  docEdition*,
  docImprint*,
  docDate*
model.pLike.front_sequenceRepeatable =
  head+,
  byline+,
  argument+,
  epigraph+,
  docTitle+,
  titlePart+,
  docAuthor+,
  docEdition+,
  docImprint+,
  docDate+
model.divBottomPart = trailer | closer | signed | postscript
model.divBottomPart_alternation = trailer | closer | signed | postscript
model.divBottomPart_sequence = trailer, closer, signed, postscript
model.divBottomPart_sequenceOptional =
  trailer?, closer?, signed?, postscript?
model.divBottomPart_sequenceOptionalRepeatable =
  trailer*, closer*, signed*, postscript*
model.divBottomPart_sequenceRepeatable =
  trailer+, closer+, signed+, postscript+
model.divBottom = model.divWrapper | model.divBottomPart
model.divBottom_alternation =
  model.divWrapper_alternation | model.divBottomPart_alternation
model.divBottom_sequence =
  model.divWrapper_sequence, model.divBottomPart_sequence
model.divBottom_sequenceOptional =
  model.divWrapper_sequenceOptional?,
  model.divBottomPart_sequenceOptional?
model.divBottom_sequenceOptionalRepeatable =
  model.divWrapper_sequenceOptionalRepeatable*,
  model.divBottomPart_sequenceOptionalRepeatable*
model.divBottom_sequenceRepeatable =
  model.divWrapper_sequenceRepeatable+,
  model.divBottomPart_sequenceRepeatable+
model.titlepagePart =
  graphic
  | binaryObject
  | byline
  | argument
  | epigraph
  | docTitle
  | titlePart
  | docAuthor
  | imprimatur
  | docEdition
  | docImprint
  | docDate
model.titlepagePart_alternation =
  graphic
  | binaryObject
  | byline
  | argument
  | epigraph
  | docTitle
  | titlePart
  | docAuthor
  | imprimatur
  | docEdition
  | docImprint
  | docDate
model.titlepagePart_sequence =
  graphic,
  binaryObject,
  byline,
  argument,
  epigraph,
  docTitle,
  titlePart,
  docAuthor,
  imprimatur,
  docEdition,
  docImprint,
  docDate
model.titlepagePart_sequenceOptional =
  graphic?,
  binaryObject?,
  byline?,
  argument?,
  epigraph?,
  docTitle?,
  titlePart?,
  docAuthor?,
  imprimatur?,
  docEdition?,
  docImprint?,
  docDate?
model.titlepagePart_sequenceOptionalRepeatable =
  graphic*,
  binaryObject*,
  byline*,
  argument*,
  epigraph*,
  docTitle*,
  titlePart*,
  docAuthor*,
  imprimatur*,
  docEdition*,
  docImprint*,
  docDate*
model.titlepagePart_sequenceRepeatable =
  graphic+,
  binaryObject+,
  byline+,
  argument+,
  epigraph+,
  docTitle+,
  titlePart+,
  docAuthor+,
  imprimatur+,
  docEdition+,
  docImprint+,
  docDate+
model.msQuoteLike =
  title | colophon | explicit | finalRubric | incipit | rubric
model.msQuoteLike_alternation =
  title | colophon | explicit | finalRubric | incipit | rubric
model.msQuoteLike_sequence =
  title, colophon, explicit, finalRubric, incipit, rubric
model.msQuoteLike_sequenceOptional =
  title?, colophon?, explicit?, finalRubric?, incipit?, rubric?
model.msQuoteLike_sequenceOptionalRepeatable =
  title*, colophon*, explicit*, finalRubric*, incipit*, rubric*
model.msQuoteLike_sequenceRepeatable =
  title+, colophon+, explicit+, finalRubric+, incipit+, rubric+
model.msItemPart =
  model.biblLike
  | model.quoteLike
  | model.respLike
  | model.msQuoteLike
  | idno
  | filiation
  | msItem
  | msItemStruct
  | textLang
  | decoNote
model.msItemPart_alternation =
  model.biblLike_alternation
  | model.quoteLike_alternation
  | model.respLike_alternation
  | model.msQuoteLike_alternation
  | idno
  | filiation
  | msItem
  | msItemStruct
  | textLang
  | decoNote
model.msItemPart_sequence =
  model.biblLike_sequence,
  model.quoteLike_sequence,
  model.respLike_sequence,
  model.msQuoteLike_sequence,
  idno,
  filiation,
  msItem,
  msItemStruct,
  textLang,
  decoNote
model.msItemPart_sequenceOptional =
  model.biblLike_sequenceOptional?,
  model.quoteLike_sequenceOptional?,
  model.respLike_sequenceOptional?,
  model.msQuoteLike_sequenceOptional?,
  idno?,
  filiation?,
  msItem?,
  msItemStruct?,
  textLang?,
  decoNote?
model.msItemPart_sequenceOptionalRepeatable =
  model.biblLike_sequenceOptionalRepeatable*,
  model.quoteLike_sequenceOptionalRepeatable*,
  model.respLike_sequenceOptionalRepeatable*,
  model.msQuoteLike_sequenceOptionalRepeatable*,
  idno*,
  filiation*,
  msItem*,
  msItemStruct*,
  textLang*,
  decoNote*
model.msItemPart_sequenceRepeatable =
  model.biblLike_sequenceRepeatable+,
  model.quoteLike_sequenceRepeatable+,
  model.respLike_sequenceRepeatable+,
  model.msQuoteLike_sequenceRepeatable+,
  idno+,
  filiation+,
  msItem+,
  msItemStruct+,
  textLang+,
  decoNote+
model.choicePart =
  sic
  | corr
  | reg
  | orig
  | unclear
  | abbr
  | expan
  | ex
  | am
  | supplied
  | seg
model.choicePart_alternation =
  sic
  | corr
  | reg
  | orig
  | unclear
  | abbr
  | expan
  | ex
  | am
  | supplied
  | seg
model.choicePart_sequence =
  sic, corr, reg, orig, unclear, abbr, expan, ex, am, supplied, seg
model.choicePart_sequenceOptional =
  sic?,
  corr?,
  reg?,
  orig?,
  unclear?,
  abbr?,
  expan?,
  ex?,
  am?,
  supplied?,
  seg?
model.choicePart_sequenceOptionalRepeatable =
  sic*,
  corr*,
  reg*,
  orig*,
  unclear*,
  abbr*,
  expan*,
  ex*,
  am*,
  supplied*,
  seg*
model.choicePart_sequenceRepeatable =
  sic+,
  corr+,
  reg+,
  orig+,
  unclear+,
  abbr+,
  expan+,
  ex+,
  am+,
  supplied+,
  seg+
model.imprintPart = distributor | publisher | biblScope | pubPlace
model.imprintPart_alternation =
  distributor | publisher | biblScope | pubPlace
model.imprintPart_sequence = distributor, publisher, biblScope, pubPlace
model.imprintPart_sequenceOptional =
  distributor?, publisher?, biblScope?, pubPlace?
model.imprintPart_sequenceOptionalRepeatable =
  distributor*, publisher*, biblScope*, pubPlace*
model.imprintPart_sequenceRepeatable =
  distributor+, publisher+, biblScope+, pubPlace+
model.catDescPart = textDesc
model.catDescPart_alternation = textDesc
model.catDescPart_sequence = textDesc
model.catDescPart_sequenceOptional = textDesc?
model.catDescPart_sequenceOptionalRepeatable = textDesc*
model.catDescPart_sequenceRepeatable = textDesc+
model.settingPart = locale | activity
model.settingPart_alternation = locale | activity
model.settingPart_sequence = locale, activity
model.settingPart_sequenceOptional = locale?, activity?
model.settingPart_sequenceOptionalRepeatable = locale*, activity*
model.settingPart_sequenceRepeatable = locale+, activity+
model.textDescPart =
  channel
  | constitution
  | derivation
  | domain
  | factuality
  | interaction
  | preparedness
model.textDescPart_alternation =
  channel
  | constitution
  | derivation
  | domain
  | factuality
  | interaction
  | preparedness
model.textDescPart_sequence =
  channel,
  constitution,
  derivation,
  domain,
  factuality,
  interaction,
  preparedness
model.textDescPart_sequenceOptional =
  channel?,
  constitution?,
  derivation?,
  domain?,
  factuality?,
  interaction?,
  preparedness?
model.textDescPart_sequenceOptionalRepeatable =
  channel*,
  constitution*,
  derivation*,
  domain*,
  factuality*,
  interaction*,
  preparedness*
model.textDescPart_sequenceRepeatable =
  channel+,
  constitution+,
  derivation+,
  domain+,
  factuality+,
  interaction+,
  preparedness+
model.castItemPart = role | roleDesc | actor
model.castItemPart_alternation = role | roleDesc | actor
model.castItemPart_sequence = role, roleDesc, actor
model.castItemPart_sequenceOptional = role?, roleDesc?, actor?
model.castItemPart_sequenceOptionalRepeatable = role*, roleDesc*, actor*
model.castItemPart_sequenceRepeatable = role+, roleDesc+, actor+
model.addressLike = email | address | affiliation
model.addressLike_alternation = email | address | affiliation
model.addressLike_sequence = email, address, affiliation
model.addressLike_sequenceOptional = email?, address?, affiliation?
model.addressLike_sequenceOptionalRepeatable =
  email*, address*, affiliation*
model.addressLike_sequenceRepeatable = email+, address+, affiliation+
model.nameLike =
  model.nameLike.agent
  | model.offsetLike
  | model.placeStateLike
  | model.persNamePart
  | idno
  | rs
  | lang
  | objectName
model.nameLike_alternation =
  model.nameLike.agent_alternation
  | model.offsetLike_alternation
  | model.placeStateLike_alternation
  | model.persNamePart_alternation
  | idno
  | rs
  | lang
  | objectName
model.nameLike_sequence =
  model.nameLike.agent_sequence,
  model.offsetLike_sequence,
  model.placeStateLike_sequence,
  model.persNamePart_sequence,
  idno,
  rs,
  lang,
  objectName
model.nameLike_sequenceOptional =
  model.nameLike.agent_sequenceOptional?,
  model.offsetLike_sequenceOptional?,
  model.placeStateLike_sequenceOptional?,
  model.persNamePart_sequenceOptional?,
  idno?,
  rs?,
  lang?,
  objectName?
model.nameLike_sequenceOptionalRepeatable =
  model.nameLike.agent_sequenceOptionalRepeatable*,
  model.offsetLike_sequenceOptionalRepeatable*,
  model.placeStateLike_sequenceOptionalRepeatable*,
  model.persNamePart_sequenceOptionalRepeatable*,
  idno*,
  rs*,
  lang*,
  objectName*
model.nameLike_sequenceRepeatable =
  model.nameLike.agent_sequenceRepeatable+,
  model.offsetLike_sequenceRepeatable+,
  model.placeStateLike_sequenceRepeatable+,
  model.persNamePart_sequenceRepeatable+,
  idno+,
  rs+,
  lang+,
  objectName+
model.global =
  model.global.meta
  | model.milestoneLike
  | model.noteLike
  | model.global.edit
  | model.global.spoken
  | metamark
  | notatedMusic
  | figure
model.global_alternation =
  model.global.meta_alternation
  | model.milestoneLike_alternation
  | model.noteLike_alternation
  | model.global.edit_alternation
  | model.global.spoken_alternation
  | metamark
  | notatedMusic
  | figure
model.global_sequence =
  model.global.meta_sequence,
  model.milestoneLike_sequence,
  model.noteLike_sequence,
  model.global.edit_sequence,
  model.global.spoken_sequence,
  metamark,
  notatedMusic,
  figure
model.global_sequenceOptional =
  model.global.meta_sequenceOptional?,
  model.milestoneLike_sequenceOptional?,
  model.noteLike_sequenceOptional?,
  model.global.edit_sequenceOptional?,
  model.global.spoken_sequenceOptional?,
  metamark?,
  notatedMusic?,
  figure?
model.global_sequenceOptionalRepeatable =
  model.global.meta_sequenceOptionalRepeatable*,
  model.milestoneLike_sequenceOptionalRepeatable*,
  model.noteLike_sequenceOptionalRepeatable*,
  model.global.edit_sequenceOptionalRepeatable*,
  model.global.spoken_sequenceOptionalRepeatable*,
  metamark*,
  notatedMusic*,
  figure*
model.global_sequenceRepeatable =
  model.global.meta_sequenceRepeatable+,
  model.milestoneLike_sequenceRepeatable+,
  model.noteLike_sequenceRepeatable+,
  model.global.edit_sequenceRepeatable+,
  model.global.spoken_sequenceRepeatable+,
  metamark+,
  notatedMusic+,
  figure+
model.featureVal = model.featureVal.complex | model.featureVal.single
model.featureVal_alternation =
  model.featureVal.complex_alternation
  | model.featureVal.single_alternation
model.featureVal_sequence =
  model.featureVal.complex_sequence, model.featureVal.single_sequence
model.featureVal_sequenceOptional =
  model.featureVal.complex_sequenceOptional?,
  model.featureVal.single_sequenceOptional?
model.featureVal_sequenceOptionalRepeatable =
  model.featureVal.complex_sequenceOptionalRepeatable*,
  model.featureVal.single_sequenceOptionalRepeatable*
model.featureVal_sequenceRepeatable =
  model.featureVal.complex_sequenceRepeatable+,
  model.featureVal.single_sequenceRepeatable+
model.biblPart =
  model.respLike
  | model.imprintPart
  | edition
  | extent
  | availability
  | series
  | citedRange
  | bibl
  | relatedItem
  | msIdentifier
  | textLang
  | listRelation
  | objectIdentifier
model.biblPart_alternation =
  model.respLike_alternation
  | model.imprintPart_alternation
  | edition
  | extent
  | availability
  | series
  | citedRange
  | bibl
  | relatedItem
  | msIdentifier
  | textLang
  | listRelation
  | objectIdentifier
model.biblPart_sequence =
  model.respLike_sequence,
  model.imprintPart_sequence,
  edition,
  extent,
  availability,
  series,
  citedRange,
  bibl,
  relatedItem,
  msIdentifier,
  textLang,
  listRelation,
  objectIdentifier
model.biblPart_sequenceOptional =
  model.respLike_sequenceOptional?,
  model.imprintPart_sequenceOptional?,
  edition?,
  extent?,
  availability?,
  series?,
  citedRange?,
  bibl?,
  relatedItem?,
  msIdentifier?,
  textLang?,
  listRelation?,
  objectIdentifier?
model.biblPart_sequenceOptionalRepeatable =
  model.respLike_sequenceOptionalRepeatable*,
  model.imprintPart_sequenceOptionalRepeatable*,
  edition*,
  extent*,
  availability*,
  series*,
  citedRange*,
  bibl*,
  relatedItem*,
  msIdentifier*,
  textLang*,
  listRelation*,
  objectIdentifier*
model.biblPart_sequenceRepeatable =
  model.respLike_sequenceRepeatable+,
  model.imprintPart_sequenceRepeatable+,
  edition+,
  extent+,
  availability+,
  series+,
  citedRange+,
  bibl+,
  relatedItem+,
  msIdentifier+,
  textLang+,
  listRelation+,
  objectIdentifier+
model.frontPart = model.frontPart.drama | listBibl | divGen | titlePage
model.frontPart_alternation =
  model.frontPart.drama_alternation | listBibl | divGen | titlePage
model.frontPart_sequence =
  model.frontPart.drama_sequence, listBibl, divGen, titlePage
model.frontPart_sequenceOptional =
  model.frontPart.drama_sequenceOptional?,
  listBibl?,
  divGen?,
  titlePage?
model.frontPart_sequenceOptionalRepeatable =
  model.frontPart.drama_sequenceOptionalRepeatable*,
  listBibl*,
  divGen*,
  titlePage*
model.frontPart_sequenceRepeatable =
  model.frontPart.drama_sequenceRepeatable+,
  listBibl+,
  divGen+,
  titlePage+
model.addrPart = model.nameLike | addrLine | street | postCode | postBox
model.addrPart_alternation =
  model.nameLike_alternation | addrLine | street | postCode | postBox
model.addrPart_sequence =
  model.nameLike_sequence, addrLine, street, postCode, postBox
model.addrPart_sequenceOptional =
  model.nameLike_sequenceOptional?,
  addrLine?,
  street?,
  postCode?,
  postBox?
model.addrPart_sequenceOptionalRepeatable =
  model.nameLike_sequenceOptionalRepeatable*,
  addrLine*,
  street*,
  postCode*,
  postBox*
model.addrPart_sequenceRepeatable =
  model.nameLike_sequenceRepeatable+,
  addrLine+,
  street+,
  postCode+,
  postBox+
model.pPart.data =
  model.dateLike
  | model.measureLike
  | model.addressLike
  | model.nameLike
model.pPart.data_alternation =
  model.dateLike_alternation
  | model.measureLike_alternation
  | model.addressLike_alternation
  | model.nameLike_alternation
model.pPart.data_sequence =
  model.dateLike_sequence,
  model.measureLike_sequence,
  model.addressLike_sequence,
  model.nameLike_sequence
model.pPart.data_sequenceOptional =
  model.dateLike_sequenceOptional?,
  model.measureLike_sequenceOptional?,
  model.addressLike_sequenceOptional?,
  model.nameLike_sequenceOptional?
model.pPart.data_sequenceOptionalRepeatable =
  model.dateLike_sequenceOptionalRepeatable*,
  model.measureLike_sequenceOptionalRepeatable*,
  model.addressLike_sequenceOptionalRepeatable*,
  model.nameLike_sequenceOptionalRepeatable*
model.pPart.data_sequenceRepeatable =
  model.dateLike_sequenceRepeatable+,
  model.measureLike_sequenceRepeatable+,
  model.addressLike_sequenceRepeatable+,
  model.nameLike_sequenceRepeatable+
model.inter =
  model.egLike
  | model.oddDecl
  | model.biblLike
  | model.labelLike
  | model.listLike
  | model.stageLike
  | model.qLike
  | castList
model.inter_alternation =
  model.egLike_alternation
  | model.oddDecl_alternation
  | model.biblLike_alternation
  | model.labelLike_alternation
  | model.listLike_alternation
  | model.stageLike_alternation
  | model.qLike_alternation
  | castList
model.inter_sequence =
  model.egLike_sequence,
  model.oddDecl_sequence,
  model.biblLike_sequence,
  model.labelLike_sequence,
  model.listLike_sequence,
  model.stageLike_sequence,
  model.qLike_sequence,
  castList
model.inter_sequenceOptional =
  model.egLike_sequenceOptional?,
  model.oddDecl_sequenceOptional?,
  model.biblLike_sequenceOptional?,
  model.labelLike_sequenceOptional?,
  model.listLike_sequenceOptional?,
  model.stageLike_sequenceOptional?,
  model.qLike_sequenceOptional?,
  castList?
model.inter_sequenceOptionalRepeatable =
  model.egLike_sequenceOptionalRepeatable*,
  model.oddDecl_sequenceOptionalRepeatable*,
  model.biblLike_sequenceOptionalRepeatable*,
  model.labelLike_sequenceOptionalRepeatable*,
  model.listLike_sequenceOptionalRepeatable*,
  model.stageLike_sequenceOptionalRepeatable*,
  model.qLike_sequenceOptionalRepeatable*,
  castList*
model.inter_sequenceRepeatable =
  model.egLike_sequenceRepeatable+,
  model.oddDecl_sequenceRepeatable+,
  model.biblLike_sequenceRepeatable+,
  model.labelLike_sequenceRepeatable+,
  model.listLike_sequenceRepeatable+,
  model.stageLike_sequenceRepeatable+,
  model.qLike_sequenceRepeatable+,
  castList+
model.common = model.divPart | model.inter | model.entryLike
model.common_alternation =
  model.divPart_alternation
  | model.inter_alternation
  | model.entryLike_alternation
model.common_sequence =
  model.divPart_sequence, model.inter_sequence, model.entryLike_sequence
model.common_sequenceOptional =
  model.divPart_sequenceOptional?,
  model.inter_sequenceOptional?,
  model.entryLike_sequenceOptional?
model.common_sequenceOptionalRepeatable =
  model.divPart_sequenceOptionalRepeatable*,
  model.inter_sequenceOptionalRepeatable*,
  model.entryLike_sequenceOptionalRepeatable*
model.common_sequenceRepeatable =
  model.divPart_sequenceRepeatable+,
  model.inter_sequenceRepeatable+,
  model.entryLike_sequenceRepeatable+
model.phrase =
  model.segLike
  | model.highlighted
  | model.graphicLike
  | model.pPart.msdesc
  | model.pPart.edit
  | model.ptrLike
  | model.lPart
  | model.phrase.xml
  | model.specDescLike
  | model.pPart.data
  | model.ptrLike.form
model.phrase_alternation =
  model.segLike_alternation
  | model.highlighted_alternation
  | model.graphicLike_alternation
  | model.pPart.msdesc_alternation
  | model.pPart.edit_alternation
  | model.ptrLike_alternation
  | model.lPart_alternation
  | model.phrase.xml_alternation
  | model.specDescLike_alternation
  | model.pPart.data_alternation
  | model.ptrLike.form_alternation
model.phrase_sequence =
  model.segLike_sequence,
  model.highlighted_sequence,
  model.graphicLike_sequence,
  model.pPart.msdesc_sequence,
  model.pPart.edit_sequence,
  model.ptrLike_sequence,
  model.lPart_sequence,
  model.phrase.xml_sequence,
  model.specDescLike_sequence,
  model.pPart.data_sequence,
  model.ptrLike.form_sequence
model.phrase_sequenceOptional =
  model.segLike_sequenceOptional?,
  model.highlighted_sequenceOptional?,
  model.graphicLike_sequenceOptional?,
  model.pPart.msdesc_sequenceOptional?,
  model.pPart.edit_sequenceOptional?,
  model.ptrLike_sequenceOptional?,
  model.lPart_sequenceOptional?,
  model.phrase.xml_sequenceOptional?,
  model.specDescLike_sequenceOptional?,
  model.pPart.data_sequenceOptional?,
  model.ptrLike.form_sequenceOptional?
model.phrase_sequenceOptionalRepeatable =
  model.segLike_sequenceOptionalRepeatable*,
  model.highlighted_sequenceOptionalRepeatable*,
  model.graphicLike_sequenceOptionalRepeatable*,
  model.pPart.msdesc_sequenceOptionalRepeatable*,
  model.pPart.edit_sequenceOptionalRepeatable*,
  model.ptrLike_sequenceOptionalRepeatable*,
  model.lPart_sequenceOptionalRepeatable*,
  model.phrase.xml_sequenceOptionalRepeatable*,
  model.specDescLike_sequenceOptionalRepeatable*,
  model.pPart.data_sequenceOptionalRepeatable*,
  model.ptrLike.form_sequenceOptionalRepeatable*
model.phrase_sequenceRepeatable =
  model.segLike_sequenceRepeatable+,
  model.highlighted_sequenceRepeatable+,
  model.graphicLike_sequenceRepeatable+,
  model.pPart.msdesc_sequenceRepeatable+,
  model.pPart.edit_sequenceRepeatable+,
  model.ptrLike_sequenceRepeatable+,
  model.lPart_sequenceRepeatable+,
  model.phrase.xml_sequenceRepeatable+,
  model.specDescLike_sequenceRepeatable+,
  model.pPart.data_sequenceRepeatable+,
  model.ptrLike.form_sequenceRepeatable+
model.limitedPhrase =
  model.hiLike
  | model.emphLike
  | model.pPart.msdesc
  | model.pPart.editorial
  | model.ptrLike
  | model.phrase.xml
  | model.pPart.data
model.limitedPhrase_alternation =
  model.hiLike_alternation
  | model.emphLike_alternation
  | model.pPart.msdesc_alternation
  | model.pPart.editorial_alternation
  | model.ptrLike_alternation
  | model.phrase.xml_alternation
  | model.pPart.data_alternation
model.limitedPhrase_sequence =
  model.hiLike_sequence,
  model.emphLike_sequence,
  model.pPart.msdesc_sequence,
  model.pPart.editorial_sequence,
  model.ptrLike_sequence,
  model.phrase.xml_sequence,
  model.pPart.data_sequence
model.limitedPhrase_sequenceOptional =
  model.hiLike_sequenceOptional?,
  model.emphLike_sequenceOptional?,
  model.pPart.msdesc_sequenceOptional?,
  model.pPart.editorial_sequenceOptional?,
  model.ptrLike_sequenceOptional?,
  model.phrase.xml_sequenceOptional?,
  model.pPart.data_sequenceOptional?
model.limitedPhrase_sequenceOptionalRepeatable =
  model.hiLike_sequenceOptionalRepeatable*,
  model.emphLike_sequenceOptionalRepeatable*,
  model.pPart.msdesc_sequenceOptionalRepeatable*,
  model.pPart.editorial_sequenceOptionalRepeatable*,
  model.ptrLike_sequenceOptionalRepeatable*,
  model.phrase.xml_sequenceOptionalRepeatable*,
  model.pPart.data_sequenceOptionalRepeatable*
model.limitedPhrase_sequenceRepeatable =
  model.hiLike_sequenceRepeatable+,
  model.emphLike_sequenceRepeatable+,
  model.pPart.msdesc_sequenceRepeatable+,
  model.pPart.editorial_sequenceRepeatable+,
  model.ptrLike_sequenceRepeatable+,
  model.phrase.xml_sequenceRepeatable+,
  model.pPart.data_sequenceRepeatable+
model.divLike = \div
model.divLike_alternation = \div
model.divLike_sequence = \div
model.divLike_sequenceOptional = \div?
model.divLike_sequenceOptionalRepeatable = \div*
model.divLike_sequenceRepeatable = \div+
model.divGenLike = divGen
model.divGenLike_alternation = divGen
model.divGenLike_sequence = divGen
model.divGenLike_sequenceOptional = divGen?
model.divGenLike_sequenceOptionalRepeatable = divGen*
model.divGenLike_sequenceRepeatable = divGen+
model.div1Like = div1
model.div1Like_alternation = div1
model.div1Like_sequence = div1
model.div1Like_sequenceOptional = div1?
model.div1Like_sequenceOptionalRepeatable = div1*
model.div1Like_sequenceRepeatable = div1+
model.div2Like = div2
model.div2Like_alternation = div2
model.div2Like_sequence = div2
model.div2Like_sequenceOptional = div2?
model.div2Like_sequenceOptionalRepeatable = div2*
model.div2Like_sequenceRepeatable = div2+
model.div3Like = div3
model.div3Like_alternation = div3
model.div3Like_sequence = div3
model.div3Like_sequenceOptional = div3?
model.div3Like_sequenceOptionalRepeatable = div3*
model.div3Like_sequenceRepeatable = div3+
model.div4Like = div4
model.div4Like_alternation = div4
model.div4Like_sequence = div4
model.div4Like_sequenceOptional = div4?
model.div4Like_sequenceOptionalRepeatable = div4*
model.div4Like_sequenceRepeatable = div4+
model.div5Like = div5
model.div5Like_alternation = div5
model.div5Like_sequence = div5
model.div5Like_sequenceOptional = div5?
model.div5Like_sequenceOptionalRepeatable = div5*
model.div5Like_sequenceRepeatable = div5+
model.div6Like = div6
model.div6Like_alternation = div6
model.div6Like_sequence = div6
model.div6Like_sequenceOptional = div6?
model.div6Like_sequenceOptionalRepeatable = div6*
model.div6Like_sequenceRepeatable = div6+
model.div7Like = div7
model.div7Like_alternation = div7
model.div7Like_sequence = div7
model.div7Like_sequenceOptional = div7?
model.div7Like_sequenceOptionalRepeatable = div7*
model.div7Like_sequenceRepeatable = div7+
model.applicationLike = application
model.applicationLike_alternation = application
model.applicationLike_sequence = application
model.applicationLike_sequenceOptional = application?
model.applicationLike_sequenceOptionalRepeatable = application*
model.applicationLike_sequenceRepeatable = application+
model.teiHeaderPart = encodingDesc | profileDesc | xenoData
model.teiHeaderPart_alternation = encodingDesc | profileDesc | xenoData
model.teiHeaderPart_sequence = encodingDesc, profileDesc, xenoData
model.teiHeaderPart_sequenceOptional =
  encodingDesc?, profileDesc?, xenoData?
model.teiHeaderPart_sequenceOptionalRepeatable =
  encodingDesc*, profileDesc*, xenoData*
model.teiHeaderPart_sequenceRepeatable =
  encodingDesc+, profileDesc+, xenoData+
model.sourceDescPart = scriptStmt | recordingStmt
model.sourceDescPart_alternation = scriptStmt | recordingStmt
model.sourceDescPart_sequence = scriptStmt, recordingStmt
model.sourceDescPart_sequenceOptional = scriptStmt?, recordingStmt?
model.sourceDescPart_sequenceOptionalRepeatable =
  scriptStmt*, recordingStmt*
model.sourceDescPart_sequenceRepeatable = scriptStmt+, recordingStmt+
model.encodingDescPart =
  schemaRef
  | projectDesc
  | samplingDecl
  | editorialDecl
  | tagsDecl
  | styleDefDecl
  | refsDecl
  | listPrefixDef
  | classDecl
  | geoDecl
  | appInfo
  | charDecl
  | metDecl
  | transcriptionDesc
  | variantEncoding
  | fsdDecl
  | schemaSpec
model.encodingDescPart_alternation =
  schemaRef
  | projectDesc
  | samplingDecl
  | editorialDecl
  | tagsDecl
  | styleDefDecl
  | refsDecl
  | listPrefixDef
  | classDecl
  | geoDecl
  | appInfo
  | charDecl
  | metDecl
  | transcriptionDesc
  | variantEncoding
  | fsdDecl
  | schemaSpec
model.encodingDescPart_sequence =
  schemaRef,
  projectDesc,
  samplingDecl,
  editorialDecl,
  tagsDecl,
  styleDefDecl,
  refsDecl,
  listPrefixDef,
  classDecl,
  geoDecl,
  appInfo,
  charDecl,
  metDecl,
  transcriptionDesc,
  variantEncoding,
  fsdDecl,
  schemaSpec
model.encodingDescPart_sequenceOptional =
  schemaRef?,
  projectDesc?,
  samplingDecl?,
  editorialDecl?,
  tagsDecl?,
  styleDefDecl?,
  refsDecl?,
  listPrefixDef?,
  classDecl?,
  geoDecl?,
  appInfo?,
  charDecl?,
  metDecl?,
  transcriptionDesc?,
  variantEncoding?,
  fsdDecl?,
  schemaSpec?
model.encodingDescPart_sequenceOptionalRepeatable =
  schemaRef*,
  projectDesc*,
  samplingDecl*,
  editorialDecl*,
  tagsDecl*,
  styleDefDecl*,
  refsDecl*,
  listPrefixDef*,
  classDecl*,
  geoDecl*,
  appInfo*,
  charDecl*,
  metDecl*,
  transcriptionDesc*,
  variantEncoding*,
  fsdDecl*,
  schemaSpec*
model.encodingDescPart_sequenceRepeatable =
  schemaRef+,
  projectDesc+,
  samplingDecl+,
  editorialDecl+,
  tagsDecl+,
  styleDefDecl+,
  refsDecl+,
  listPrefixDef+,
  classDecl+,
  geoDecl+,
  appInfo+,
  charDecl+,
  metDecl+,
  transcriptionDesc+,
  variantEncoding+,
  fsdDecl+,
  schemaSpec+
model.editorialDeclPart =
  correction
  | normalization
  | quotation
  | hyphenation
  | segmentation
  | stdVals
  | interpretation
  | punctuation
model.editorialDeclPart_alternation =
  correction
  | normalization
  | quotation
  | hyphenation
  | segmentation
  | stdVals
  | interpretation
  | punctuation
model.editorialDeclPart_sequence =
  correction,
  normalization,
  quotation,
  hyphenation,
  segmentation,
  stdVals,
  interpretation,
  punctuation
model.editorialDeclPart_sequenceOptional =
  correction?,
  normalization?,
  quotation?,
  hyphenation?,
  segmentation?,
  stdVals?,
  interpretation?,
  punctuation?
model.editorialDeclPart_sequenceOptionalRepeatable =
  correction*,
  normalization*,
  quotation*,
  hyphenation*,
  segmentation*,
  stdVals*,
  interpretation*,
  punctuation*
model.editorialDeclPart_sequenceRepeatable =
  correction+,
  normalization+,
  quotation+,
  hyphenation+,
  segmentation+,
  stdVals+,
  interpretation+,
  punctuation+
model.profileDescPart =
  abstract
  | creation
  | langUsage
  | textClass
  | calendarDesc
  | correspDesc
  | handNotes
  | listTranspose
  | textDesc
  | particDesc
  | settingDesc
model.profileDescPart_alternation =
  abstract
  | creation
  | langUsage
  | textClass
  | calendarDesc
  | correspDesc
  | handNotes
  | listTranspose
  | textDesc
  | particDesc
  | settingDesc
model.profileDescPart_sequence =
  abstract,
  creation,
  langUsage,
  textClass,
  calendarDesc,
  correspDesc,
  handNotes,
  listTranspose,
  textDesc,
  particDesc,
  settingDesc
model.profileDescPart_sequenceOptional =
  abstract?,
  creation?,
  langUsage?,
  textClass?,
  calendarDesc?,
  correspDesc?,
  handNotes?,
  listTranspose?,
  textDesc?,
  particDesc?,
  settingDesc?
model.profileDescPart_sequenceOptionalRepeatable =
  abstract*,
  creation*,
  langUsage*,
  textClass*,
  calendarDesc*,
  correspDesc*,
  handNotes*,
  listTranspose*,
  textDesc*,
  particDesc*,
  settingDesc*
model.profileDescPart_sequenceRepeatable =
  abstract+,
  creation+,
  langUsage+,
  textClass+,
  calendarDesc+,
  correspDesc+,
  handNotes+,
  listTranspose+,
  textDesc+,
  particDesc+,
  settingDesc+
model.correspActionPart =
  model.dateLike | model.addressLike | model.nameLike | note
model.correspActionPart_alternation =
  model.dateLike_alternation
  | model.addressLike_alternation
  | model.nameLike_alternation
  | note
model.correspActionPart_sequence =
  model.dateLike_sequence,
  model.addressLike_sequence,
  model.nameLike_sequence,
  note
model.correspActionPart_sequenceOptional =
  model.dateLike_sequenceOptional?,
  model.addressLike_sequenceOptional?,
  model.nameLike_sequenceOptional?,
  note?
model.correspActionPart_sequenceOptionalRepeatable =
  model.dateLike_sequenceOptionalRepeatable*,
  model.addressLike_sequenceOptionalRepeatable*,
  model.nameLike_sequenceOptionalRepeatable*,
  note*
model.correspActionPart_sequenceRepeatable =
  model.dateLike_sequenceRepeatable+,
  model.addressLike_sequenceRepeatable+,
  model.nameLike_sequenceRepeatable+,
  note+
model.correspContextPart = model.ptrLike | model.pLike | note
model.correspContextPart_alternation =
  model.ptrLike_alternation | model.pLike_alternation | note
model.correspContextPart_sequence =
  model.ptrLike_sequence, model.pLike_sequence, note
model.correspContextPart_sequenceOptional =
  model.ptrLike_sequenceOptional?, model.pLike_sequenceOptional?, note?
model.correspContextPart_sequenceOptionalRepeatable =
  model.ptrLike_sequenceOptionalRepeatable*,
  model.pLike_sequenceOptionalRepeatable*,
  note*
model.correspContextPart_sequenceRepeatable =
  model.ptrLike_sequenceRepeatable+,
  model.pLike_sequenceRepeatable+,
  note+
model.correspDescPart = correspAction | correspContext | note
model.correspDescPart_alternation =
  correspAction | correspContext | note
model.correspDescPart_sequence = correspAction, correspContext, note
model.correspDescPart_sequenceOptional =
  correspAction?, correspContext?, note?
model.correspDescPart_sequenceOptionalRepeatable =
  correspAction*, correspContext*, note*
model.correspDescPart_sequenceRepeatable =
  correspAction+, correspContext+, note+
att.partials.attributes = att.partials.attribute.extent
att.partials.attribute.extent =
  
  ## indicates whether the pronunciation or orthography applies to all or part of a word.
  ## Suggested values include: 1] full (full form) ; 2] pref (prefix) ; 3] suff (suffix) ; 4] inf (infix) ; 5] part (partial) 
  attribute extent {
    
    ## (full form) 
    "full"
    | 
      ## (prefix) 
      "pref"
    | 
      ## (suffix) 
      "suff"
    | 
      ## (infix) 
      "inf"
    | 
      ## (partial) 
      "part"
    | xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
  }?
model.resourceLike = \text | facsimile | sourceDoc | fsdDecl
model.resourceLike_alternation = \text | facsimile | sourceDoc | fsdDecl
model.resourceLike_sequence = \text, facsimile, sourceDoc, fsdDecl
model.resourceLike_sequenceOptional =
  \text?, facsimile?, sourceDoc?, fsdDecl?
model.resourceLike_sequenceOptionalRepeatable =
  \text*, facsimile*, sourceDoc*, fsdDecl*
model.resourceLike_sequenceRepeatable =
  \text+, facsimile+, sourceDoc+, fsdDecl+
model.objectLike = object | listObject
model.objectLike_alternation = object | listObject
model.objectLike_sequence = object, listObject
model.objectLike_sequenceOptional = object?, listObject?
model.objectLike_sequenceOptionalRepeatable = object*, listObject*
model.objectLike_sequenceRepeatable = object+, listObject+
model.orgStateLike = state
model.orgStateLike_alternation = state
model.orgStateLike_sequence = state
model.orgStateLike_sequenceOptional = state?
model.orgStateLike_sequenceOptionalRepeatable = state*
model.orgStateLike_sequenceRepeatable = state+
att.personal.attributes =
  att.naming.attributes,
  att.personal.attribute.full,
  att.personal.attribute.sort
att.personal.attribute.full =
  
  ## indicates whether the name component is given in full, as an abbreviation or simply as an initial.
  [ a:defaultValue = "yes" ]
  attribute full {
    
    ## the name component is spelled out in full.
    "yes"
    | 
      ## (abbreviated) the name component is given in an abbreviated form.
      "abb"
    | 
      ## (initial letter) the name component is indicated only by one initial.
      "init"
  }?
att.personal.attribute.sort =
  
  ## specifies the sort order of the name component in relation to others within the name.
  attribute sort { xsd:nonNegativeInteger }?
model.placeLike = place
model.placeLike_alternation = place
model.placeLike_sequence = place
model.placeLike_sequenceOptional = place?
model.placeLike_sequenceOptionalRepeatable = place*
model.placeLike_sequenceRepeatable = place+
att.duration.iso.attributes = att.duration.iso.attribute.dur-iso
att.duration.iso.attribute.dur-iso =
  
  ## (duration) indicates the length of this element in time.
  attribute dur-iso {
    xsd:token { pattern = "[0-9.,DHMPRSTWYZ/:+\-]+" }
  }?
# 2. elements

# 3. macros
macro.paraContent =
  (text
   | model.gLike
   | model.phrase
   | model.inter
   | model.global
   | lg
   | model.lLike)*
macro.limitedContent = (text | model.limitedPhrase | model.inter)*
macro.phraseSeq =
  (text | model.gLike | model.qLike | model.phrase | model.global)*
macro.phraseSeq.limited = (text | model.limitedPhrase | model.global)*
macro.specialPara =
  (text
   | model.gLike
   | model.phrase
   | model.inter
   | model.divPart
   | model.global)*
macro.xtext = (text | model.gLike)*
teidata.certainty =
  
  ##
  "high"
  | 
    ##
    "medium"
  | 
    ##
    "low"
  | 
    ##
    "unknown"
teidata.probability = xsd:double
teidata.numeric =
  xsd:double
  | xsd:token { pattern = "(\-?[\d]+/\-?[\d]+)" }
  | xsd:decimal
teidata.interval =
  xsd:float
  | (
     ##
     "regular"
     | 
       ##
       "irregular"
     | 
       ##
       "unknown")
teidata.count = xsd:nonNegativeInteger
teidata.temporal.w3c =
  xsd:date
  | xsd:gYear
  | xsd:gMonth
  | xsd:gDay
  | xsd:gYearMonth
  | xsd:gMonthDay
  | xsd:time
  | xsd:dateTime
teidata.duration.w3c = xsd:duration
teidata.truthValue = xsd:boolean
teidata.xTruthValue =
  xsd:boolean
  | (
     ##
     "unknown"
     | 
       ##
       "inapplicable")
teidata.language =
  xsd:language
  | (
     ##
     "")
teidata.namespace = xsd:anyURI
teidata.namespaceOrName =
  xsd:anyURI { pattern = "[^/]+:.*" }
  | xsd:Name { pattern = ".+:.+" }
teidata.outputMeasurement =
  xsd:token {
    pattern =
      "[\-+]?\d+(\.\d+)?(%|cm|mm|in|pt|pc|px|em|ex|gd|rem|vw|vh|vm)"
  }
teidata.pattern = xsd:token
teidata.point =
  xsd:token { pattern = "(\-?[0-9]+\.?[0-9]*,\-?[0-9]+\.?[0-9]*)" }
teidata.pointer = xsd:anyURI
teidata.version = xsd:token { pattern = "[\d]+(\.[\d]+){0,2}" }
teidata.versionNumber =
  xsd:token { pattern = "[\d]+[a-z]*[\d]*(\.[\d]+[a-z]*[\d]*){0,3}" }
teidata.replacement = text
teidata.xpath = text
teidata.word = xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
teidata.sex = xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
teidata.text = xsd:string
teidata.name = xsd:Name
teidata.xmlName = xsd:NCName
teidata.prefix = xsd:token { pattern = "[a-z][a-z0-9\+\.\-]*" }
teidata.enumerated =
  xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
teidata.probCert =
  xsd:double
  | (
     ##
     "high"
     | 
       ##
       "medium"
     | 
       ##
       "low"
     | 
       ##
       "unknown")
teidata.unboundedInt =
  xsd:nonNegativeInteger
  | (
     ##
     "unbounded")
teidata.nullOrName =
  (
   ##
   "")
  | xsd:NCName
teidata.temporal.iso =
  xsd:date
  | xsd:gYear
  | xsd:gMonth
  | xsd:gDay
  | xsd:gYearMonth
  | xsd:gMonthDay
  | xsd:time
  | xsd:dateTime
  | xsd:token { pattern = "[0-9.,DHMPRSTWYZ/:+\-]+" }
teidata.duration.iso = xsd:token { pattern = "[0-9.,DHMPRSTWYZ/:+\-]+" }
